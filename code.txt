
class CBaseMonster : public CCustomMonster, public CStepManager, public CInventoryOwner 
{
	typedef	CCustomMonster								inherited;
	
public:
							CBaseMonster						();
	virtual					~CBaseMonster						();

public:
	virtual	Feel::Sound*				dcast_FeelSound				()	{ return this;	}
	virtual	CCharacterPhysicsSupport*	character_physics_support	()	{return m_pPhysics_support;}
	virtual CPHDestroyable*				ph_destroyable				();
	virtual CEntityAlive*				cast_entity_alive			()	{return this;}
	virtual CEntity*					cast_entity					()	{return this;}
	virtual CPhysicsShellHolder*		cast_physics_shell_holder	()	{return this;}
	virtual CParticlesPlayer*			cast_particles_player		()	{return this;}
	virtual CCustomMonster*				cast_custom_monster			()	{return this;}
	virtual CScriptEntity*				cast_script_entity			()	{return this;}
	virtual CBaseMonster*				cast_base_monster			()	{return this;}

	virtual CInventoryOwner				*cast_inventory_owner		() {return this;}
	virtual CGameObject*				cast_game_object			() {return this;}

public:
	
	virtual	BOOL			renderable_ShadowReceive		()	{ return TRUE;	}  
	virtual void			Die								(CObject* who);
	virtual void			HitSignal						(float amount, Fvector& vLocalDir, CObject* who, s16 element);
	virtual	void			Hit								(SHit* pHDS);
	virtual	void			PHHit							(float P,Fvector &dir, CObject *who,s16 element,Fvector p_in_object_space, float impulse, ALife::EHitType hit_type = ALife::eHitTypeWound);
	virtual void			SelectAnimation					(const Fvector& _view, const Fvector& _move, float speed );

	virtual void			Load							(LPCSTR section);
	virtual DLL_Pure		*_construct						();

	virtual BOOL			net_Spawn						(CSE_Abstract* DC);
	virtual void			net_Destroy						();
	virtual void			net_Save						(NET_Packet& P);
	virtual	BOOL			net_SaveRelevant				();
	virtual void			net_Export						(NET_Packet& P);
	virtual void			net_Import						(NET_Packet& P);
	virtual void			net_Relcase						(CObject *O);

	//save/load server serialization
	virtual void			save							(NET_Packet &output_packet) {inherited::save(output_packet);}
	virtual void			load							(IReader &input_packet)		{inherited::load(input_packet);}


	virtual void			UpdateCL						();
	virtual void			shedule_Update					(u32 dt);

	virtual void			InitThink						() {}
	virtual void			Think							();
	virtual	void			reinit							();
	virtual void			reload							(LPCSTR section);

	virtual void			init							() {}

	virtual void			feel_sound_new					(CObject* who, int eType, CSound_UserDataPtr user_data, const Fvector &Position, float power);
	virtual BOOL			feel_vision_isRelevant			(CObject* O);
	virtual BOOL			feel_touch_on_contact			(CObject* O);
	virtual BOOL			feel_touch_contact				(CObject *);

	virtual bool			useful							(const CItemManager *manager, const CGameObject *object) const;
	virtual float			evaluate						(const CItemManager *manager, const CGameObject *object) const;

	virtual void			OnEvent							(NET_Packet& P, u16 type);
	virtual void			OnHUDDraw						(CCustomHUD* hud)			{return inherited::OnHUDDraw(hud);}
	virtual u16				PHGetSyncItemsNumber			()							{return inherited::PHGetSyncItemsNumber();}
	virtual CPHSynchronize*	PHGetSyncItem					(u16 item)					{return inherited::PHGetSyncItem(item);}
	virtual void			PHUnFreeze						()							{return inherited::PHUnFreeze();}
	virtual void			PHFreeze						()							{return inherited::PHFreeze();}
	virtual BOOL			UsedAI_Locations				()							{return inherited::UsedAI_Locations();}

	virtual const SRotation	Orientation						() const					{return inherited::Orientation();}
	virtual void			renderable_Render				()							{return inherited::renderable_Render();} 

	virtual	void			on_restrictions_change			();

	virtual	void			SetAttackEffector				();
	
	virtual void			update_fsm						();
			
	virtual	void			post_fsm_update					();
			void			squad_notify					();

	virtual bool			IsTalkEnabled					() {return false;}

	ALife::EHitType			hit_type;
	float					hit_power;
	LPCSTR					hit_mark;
	ALife::EHitType			jump_hit_type;
	LPCSTR					jump_hit_mark;
	virtual void			HitEntity						(const CEntity *pEntity, float fDamage, float impulse, Fvector &dir, ALife::EHitType hit_type, LPCSTR hit_mark, bool use_secondary = false);
	virtual	void			HitEntityInJump					(const CEntity *pEntity) {}

	virtual	void			on_before_sell					(CInventoryItem *item);
			float			GetSatiety						()							{return 0.5f;}
			void			ChangeSatiety					(float v)					{}
	        float			m_vampire_want_speed;
	// ---------------------------------------------------------------------------------
	// Process scripts
	// ---------------------------------------------------------------------------------
	virtual	bool			bfAssignMovement				(CScriptEntityAction	*tpEntityAction);
	virtual	bool			bfAssignObject					(CScriptEntityAction	*tpEntityAction);
	virtual	bool			bfAssignWatch					(CScriptEntityAction	*tpEntityAction);
	virtual bool			bfAssignAnimation				(CScriptEntityAction  *tpEntityAction);
	virtual	bool			bfAssignMonsterAction			(CScriptEntityAction	*tpEntityAction);
	virtual bool			bfAssignSound					(CScriptEntityAction *tpEntityAction);
	
	virtual	void			vfFinishAction					(CScriptEntityAction		*tpEntityAction);
	
	virtual void			ProcessScripts					();

	virtual	CEntity			*GetCurrentEnemy				();
	virtual	CEntity 		*GetCurrentCorpse				();
	virtual int				get_enemy_strength				();
	
	virtual void			SetScriptControl				(const bool bScriptControl, shared_str caSciptName);


	bool					m_force_real_speed;
	bool					m_script_processing_active;
	bool					m_script_state_must_execute;


	virtual void			jump							(const Fvector &position, float factor) {}

	bool					m_skip_transfer_enemy;			
	IC		void			skip_transfer_enemy				(bool value){m_skip_transfer_enemy = value;}
	
	IC		int				Rank							(){return m_rank;}

	//----------------------------------------------------------------------------------

	virtual void			SetTurnAnimation				(bool turn_left);
	
	// установка специфических анимаций 
	virtual	void			CheckSpecParams					(u32 /**spec_params/**/) {}
	virtual void			ForceFinalAnimation				() {}
	virtual void			LookPosition					(Fvector to_point, float angular_speed = PI_DIV_3);		// каждый монстр может по-разному реализвать эту функ (e.g. кровосос с поворотом головы и т.п.)

	// Team	
	virtual void			ChangeTeam						(int team, int squad, int group);
		
	// ---------------------------------------------------------------------------------
	// Abilities
	// ---------------------------------------------------------------------------------
	virtual bool			ability_invisibility			() {return false;}
	virtual bool			ability_can_drag				() {return false;}
	virtual bool			ability_psi_attack				() {return false;}
	virtual bool			ability_earthquake				() {return false;}
	virtual bool			ability_can_jump				() {return false;}
	virtual bool			ability_distant_feel			() {return false;}
	virtual bool			ability_run_attack				() {return false;}
	virtual bool			ability_rotation_jump			() {return false;}
	virtual bool			ability_jump_over_physics		() {return false;}
	virtual bool			ability_pitch_correction		() {return true;}
	// ---------------------------------------------------------------------------------
	
	virtual void			event_on_step					() {}
	virtual void			on_threaten_execute				() {}
	// ---------------------------------------------------------------------------------
	// Memory
			void			UpdateMemory					();
			
	// Cover
			bool			GetCorpseCover					(Fvector &position, u32 &vertex_id);
			bool			GetCoverFromEnemy				(const Fvector &enemy_pos, Fvector &position, u32 &vertex_id);
			bool			GetCoverFromPoint				(const Fvector &pos, Fvector &position, u32 &vertex_id, float min_dist, float max_dist, float radius);
			bool			GetCoverCloseToPoint			(const Fvector &dest_pos, float min_dist, float max_dist, float deviation, float radius ,Fvector &position, u32 &vertex_id);





	// Movement Manager
protected:
	CControlPathBuilder			*m_movement_manager;
protected:
	virtual CMovementManager	*create_movement_manager();

// members
public:
	// --------------------------------------------------------------------------------------
	// Monster Settings 
	ref_smem<SMonsterSettings>	m_base_settings;
	ref_smem<SMonsterSettings>	m_current_settings;
	
	void						settings_read			(const CInifile *ini, LPCSTR section, SMonsterSettings &data);
	void						settings_load			(LPCSTR section);
	void						settings_overrides		();

	SMonsterSettings			&db						() {return *(*m_current_settings);}
	// --------------------------------------------------------------------------------------

	CCharacterPhysicsSupport	*m_pPhysics_support;
	
	
	CMonsterCorpseCoverEvaluator	*m_corpse_cover_evaluator;
	CCoverEvaluatorFarFromEnemy		*m_enemy_cover_evaluator;
	CCoverEvaluatorCloseToEnemy		*m_cover_evaluator_close_point;

	// ---------------------------------------------------------------------------------
	IStateManagerBase		*StateMan;
	// ---------------------------------------------------------------------------------

	CMonsterEnemyMemory		EnemyMemory;
	CMonsterSoundMemory		SoundMemory;
	CMonsterCorpseMemory	CorpseMemory;
	CMonsterHitMemory		HitMemory;

	CMonsterEnemyManager	EnemyMan;
	CMonsterCorpseManager	CorpseMan;

	bool					hear_dangerous_sound;
	bool					hear_interesting_sound;

	// -----------------------------------------------------------------------------
	CMonsterEventManager	EventMan;
	// -----------------------------------------------------------------------------

	CMeleeChecker			MeleeChecker;
	CMonsterMorale			Morale;

	// -----------------------------------------------------------------------------

	CMonsterCoverManager	*CoverMan;

	// -----------------------------------------------------------------------------

	CControlledEntityBase	*m_controlled;	

	// -----------------------------------------------------------------------------
	enum EMonsterType {
		eMonsterTypeUniversal	= u32(0),
		eMonsterTypeIndoor,
		eMonsterTypeOutdoor,
	} m_monster_type;

	// -----------------------------------------------------------------------------
	// Home
	CMonsterHome			*Home;


	// -----------------------------------------------------------------------------
	// Anomaly Detector
private:
	CAnomalyDetector		*m_anomaly_detector;

public:
	CAnomalyDetector		&anomaly_detector	() {return (*m_anomaly_detector);}
	// -----------------------------------------------------------------------------

	void					anomaly_detector_enable	(bool state);
	bool					anomaly_detector_enabled();		

//	//-----------------------------------------------------------------
//	// Spawn Inventory Item
//	//-----------------------------------------------------------------
//private:
//	LPCSTR					m_item_section;
//	float					m_spawn_probability;

	//--------------------------------------------------------------------
	// Berserk
	//--------------------------------------------------------------------
public:
	u32						time_berserk_start;
	IC void					set_berserk						() {time_berserk_start = time();}
	bool					berserk_always;

	//--------------------------------------------------------------------
	// Panic Threshold (extension for scripts)
	//--------------------------------------------------------------------

		float				m_default_panic_threshold;
	IC	void				set_custom_panic_threshold	(float value);
	IC	void				set_default_panic_threshold	();
	//--------------------------------------------------------------------




	//////////////////////////////////////////////////////////////////////////
	// -----------------------------------------------------------------------------
	// Special Services (refactoring needed)
		
	void				on_kill_enemy				(const CEntity *obj);
	void				Hit_Psy						(CObject *object, float value);
	CParticlesObject	*PlayParticles				(const shared_str& name, const Fvector &position, const Fvector &dir, BOOL auto_remove = TRUE, BOOL xformed = TRUE);
	void				load_effector				(LPCSTR section, LPCSTR line, SAttackEffector &effector);

	// --------------------------------------------------------------------------------------
	// Kill From Here
	// --------------------------------------------------------------------------------------
	// State flags
	bool						m_bDamaged;
	bool						m_bAngry;
	bool						m_bGrowling;
	bool						m_bAggressive;
	bool						m_bSleep;
	bool						m_bRunTurnLeft;
	bool						m_bRunTurnRight;


	void						set_aggressive				(bool val = true) {m_bAggressive = val;}

	//---------------------------------------------------------------------------------------


	u32						m_prev_sound_type;
	u32						get_attack_rebuild_time	();

	IC	virtual	EAction		CustomVelocityIndex2Action	(u32 velocity_index) {return ACT_STAND_IDLE;}
		virtual	void		TranslateActionToPathParams ();
	
	bool					state_invisible;

	void					set_action			(EAction action);
	void					set_state_sound		(u32 type, bool once = false);
IC	void					fall_asleep			(){m_bSleep = true;}
IC	void					wake_up				(){m_bSleep = false;}

	// Temp
	u32						m_time_last_attack_success;
	int						m_rank;
	float					m_melee_rotation_factor;

private:
	bool					ignore_collision_hit;	
	
public:
	IC	void				set_ignore_collision_hit (bool value) {ignore_collision_hit = value;}
	// -----------------------------------------------------------------------------
	//////////////////////////////////////////////////////////////////////////


public:
	CControl_Manager		&control() {return (*m_control_manager);}
	
	CControlAnimationBase	&anim	(){return (*m_anim_base);}
	CControlMovementBase	&move	(){return (*m_move_base);}
	CControlPathBuilderBase	&path	(){return (*m_path_base);}
	CControlDirectionBase	&dir	(){return (*m_dir_base);}
	
	CControlManagerCustom	&com_man() {return m_com_manager;}

	virtual bool			check_start_conditions	(ControlCom::EControlType);
	virtual void			on_activate_control		(ControlCom::EControlType){}

protected:
	CControl_Manager		*m_control_manager;
	
	CControlAnimationBase	*m_anim_base;
	CControlMovementBase	*m_move_base;
	CControlPathBuilderBase	*m_path_base;
	CControlDirectionBase	*m_dir_base;

	CControlManagerCustom	m_com_manager;

	virtual void			create_base_controls	();



	//////////////////////////////////////////////////////////////////////////
	// Critical Wounded
	//////////////////////////////////////////////////////////////////////////
	enum {
		critical_wound_type_head	= u32(0),
		critical_wound_type_torso,
		critical_wound_type_legs
	};
	
	virtual void			load_critical_wound_bones					();
	virtual bool			critical_wound_external_conditions_suitable	();
	virtual void			critical_wounded_state_start				();
	
			void			fill_bones_body_parts						(LPCSTR body_part, CriticalWoundType wound_type);
	
	LPCSTR					m_critical_wound_anim_head;
	LPCSTR					m_critical_wound_anim_torso;
	LPCSTR					m_critical_wound_anim_legs;

	//////////////////////////////////////////////////////////////////////////
	

public:	


//////////////////////////////////////////////////////////////////////////
// DEBUG stuff
#ifdef DEBUG
public:
	struct SDebugInfo {
		bool	active;
		float	x;
		float	y;
		float	delta_y;
		u32		color;
		u32		delimiter_color;

		SDebugInfo() : active(false) {}
		SDebugInfo(float px, float py, float dy, u32 c, u32 dc) : active(true), x(px), y(py), delta_y(dy), color (c), delimiter_color(dc) {}
	};
	
	u8						m_show_debug_info;	// 0 - none, 1 - first column, 2 - second column
	void					set_show_debug_info	(u8 show = 1){m_show_debug_info = show;}
	virtual	SDebugInfo		show_debug_info		();

	void					debug_fsm			();
#endif

#ifdef _DEBUG
	virtual void			debug_on_key		(int key) {}
#endif
//////////////////////////////////////////////////////////////////////////

public:
	virtual bool					can_be_seen		() const { return true; }

	//-------------------------------------------------------------------
	// CBaseMonster's  Auras
	//-------------------------------------------------------------------
public:

	bool psy_aura_enabled_for_dead() const;
	bool radiation_aura_enabled_for_dead() const;
	bool fire_aura_enabled_for_dead() const;
	bool shock_aura_enabled_for_dead() const;
	bool chemical_aura_enabled_for_dead() const;
	bool biological_aura_enabled_for_dead() const;

	float get_psy_aura_influence();
	float get_radiation_aura_influence();
	float get_fire_aura_influence();
	float get_shock_aura_influence();
	float get_chemical_aura_influence();
	float get_biological_aura_influence();

	void play_detector_sound();

private:
	monster_aura m_psy_aura;
	monster_aura m_radiation_aura;
	monster_aura m_fire_aura;
	monster_aura m_shock_aura;
	monster_aura m_chemical_aura;
	monster_aura m_biological_aura;
	monster_aura m_base_aura;

protected:
	//-------------------------------------------------------------------
	// CBaseMonster's  protections
	//-------------------------------------------------------------------
	float m_fSkinArmor;
	float m_fHitFracMonster;
	float m_fWeakHitFracMonster;
};

CBaseMonster::CBaseMonster()
	: m_psy_aura(this, "psy"), m_radiation_aura(this, "radiation"), m_fire_aura(this, "fire"), m_shock_aura(this, "shock"), m_chemical_aura(this, "chemical"), m_biological_aura(this, "biological"), m_base_aura(this, "base")
{
	m_pPhysics_support=new CCharacterPhysicsSupport(CCharacterPhysicsSupport::etBitting,this);
	
	m_pPhysics_support				->in_Init();

	// Components external init 
	
	m_control_manager				= new CControl_Manager(this);


	EnemyMemory.init_external		(this, 20000);
	SoundMemory.init_external		(this, 20000);
	CorpseMemory.init_external		(this, 20000);
	HitMemory.init_external			(this, 50000);

	EnemyMan.init_external			(this);
	CorpseMan.init_external			(this);

	// Инициализация параметров анимации	

	StateMan						= 0;

	MeleeChecker.init_external		(this);
	Morale.init_external			(this);

	m_controlled					= 0;

	
	control().add					(&m_com_manager,  ControlCom::eControlCustom);
	
	m_com_manager.add_ability		(ControlCom::eControlSequencer);
	m_com_manager.add_ability		(ControlCom::eControlTripleAnimation);


	m_anomaly_detector				= new CAnomalyDetector(this);
	CoverMan						= new CMonsterCoverManager(this);

	Home							= new CMonsterHome(this);

	com_man().add_ability			(ControlCom::eComCriticalWound);
}


CBaseMonster::~CBaseMonster()
{
	xr_delete(m_pPhysics_support);
	xr_delete(m_corpse_cover_evaluator);
	xr_delete(m_enemy_cover_evaluator);
	xr_delete(m_cover_evaluator_close_point);
	
	xr_delete(m_control_manager);

	xr_delete(m_anim_base);
	xr_delete(m_move_base);
	xr_delete(m_path_base);
	xr_delete(m_dir_base);

	xr_delete(m_anomaly_detector);
	xr_delete(CoverMan);
	xr_delete(Home);
}

void CBaseMonster::UpdateCL()
{
	inherited::UpdateCL();
	
	if (g_Alive()) {
		CStepManager::update				();
	}

	control().update_frame();

	m_pPhysics_support->in_UpdateCL();
}

void CBaseMonster::shedule_Update(u32 dt)
{
	inherited::shedule_Update(dt);

	m_psy_aura.update_schedule();
	m_fire_aura.update_schedule();
	m_base_aura.update_schedule();
	m_radiation_aura.update_schedule();
	m_shock_aura.update_schedule();
	m_chemical_aura.update_schedule();
	m_biological_aura.update_schedule();

	control().update_schedule();

	Morale.update_schedule(dt);

	m_anomaly_detector->update_schedule();

	m_pPhysics_support->in_shedule_Update(dt);

#ifdef DEBUG
	show_debug_info();
#endif
}

void CBaseMonster::anomaly_detector_enable(bool state)
{ 
	if (state)
		anomaly_detector().activate();
	else
		anomaly_detector().deactivate();
}

bool CBaseMonster::anomaly_detector_enabled()
{ 
	return anomaly_detector().active(); 
}

//////////////////////////////////////////////////////////////////////
// Other functions
//////////////////////////////////////////////////////////////////////


void CBaseMonster::Die(CObject* who)
{
	if (StateMan)
		StateMan->critical_finalize();

	m_psy_aura.on_monster_death();
	m_radiation_aura.on_monster_death();
	m_fire_aura.on_monster_death();
	m_shock_aura.on_monster_death();
	m_chemical_aura.on_monster_death();
	m_biological_aura.on_monster_death();
	m_base_aura.on_monster_death();

	inherited::Die(who);

	if (is_special_killer(who))
		sound().play(MonsterSound::eMonsterSoundDieInAnomaly);
	else
		sound().play(MonsterSound::eMonsterSoundDie);

	monster_squad().remove_member((u8)g_Team(), (u8)g_Squad(), (u8)g_Group(), this);
	
	if (m_controlled)
		m_controlled->on_die();
}


void CBaseMonster::Hit(SHit* pHDS)
{
	if (ignore_collision_hit && (pHDS->hit_type == ALife::eHitTypePhysicStrike))
		return;

	if (invulnerable())
		return;

	if (g_Alive())
		if (!critically_wounded())
			update_critical_wounded(pHDS->boneID, pHDS->power);

	LPCSTR hit_type_name = ALife::g_cafHitType2String(pHDS->hit_type);
	Msg("%s Hit: hit_type = %s | hit_power = %f | ap = %.2f | bone = %d | bone name = %s | use_secondary = %d | original",
		*cName(), hit_type_name, pHDS->power, pHDS->ap, pHDS->bone(), smart_cast<IKinematics*>(Visual())->LL_BoneName_dbg(pHDS->bone()), pHDS->use_secondary);

	if(pHDS->hit_type == ALife::eHitTypeFireWound)
	{
		pHDS->power = conditions().HitArmorEffect(pHDS->power, pHDS->hit_type, m_fHitFracMonster, m_fWeakHitFracMonster, pHDS->ap, m_fSkinArmor, pHDS->add_wound);

		Msg("%s Hit: hit_type = %s | hit_power = %f | hit_fraction = %.2f | weak_hit_fraction = %.2f | armor = %.2f | after armor",
			*cName(), hit_type_name, pHDS->power, m_fHitFracMonster, m_fWeakHitFracMonster, m_fSkinArmor);
	}

	inherited::Hit(pHDS);
}

void CBaseMonster::PHHit(float P,Fvector &dir, CObject *who,s16 element,Fvector p_in_object_space, float impulse, ALife::EHitType hit_type)
{
	m_pPhysics_support->in_Hit(P,dir,who,element,p_in_object_space,impulse,hit_type);
}

CPHDestroyable*	CBaseMonster::	ph_destroyable	()
{
	return smart_cast<CPHDestroyable*>(character_physics_support());
}

bool CBaseMonster::useful(const CItemManager *manager, const CGameObject *object) const
{
	if (!movement().restrictions().accessible(object->Position()))
		return				(false);

	if (!ai().level_graph().valid_vertex_id(object->ai_location().level_vertex_id()))
		return			    (false);

	if (!movement().restrictions().accessible(object->ai_location().level_vertex_id()))
		return				(false);

	const CEntityAlive *pCorpse = smart_cast<const CEntityAlive *>(object); 
	if (!pCorpse) return false;
	
	if (!pCorpse->g_Alive()) return true;
	return false;
}

float CBaseMonster::evaluate(const CItemManager *manager, const CGameObject *object) const
{
	return (0.f);
}

//////////////////////////////////////////////////////////////////////////

void CBaseMonster::ChangeTeam(int team, int squad, int group)
{
	if ((team == g_Team()) && (squad == g_Squad()) && (group == g_Group())) return;

#ifdef DEBUG
	if (!g_Alive()) {
		ai().script_engine().print_stack	();
		VERIFY2								(g_Alive(),"you are trying to change team of a dead entity");
	}
#endif // DEBUG

	// remove from current team
	monster_squad().remove_member	((u8)g_Team(),(u8)g_Squad(),(u8)g_Group(),this);
	inherited::ChangeTeam			(team,squad,group);
	monster_squad().register_member	((u8)g_Team(),(u8)g_Squad(),(u8)g_Group(), this);
}


void CBaseMonster::SetTurnAnimation(bool turn_left)
{
	(turn_left) ? anim().SetCurAnim(eAnimStandTurnLeft) : anim().SetCurAnim(eAnimStandTurnRight);
}

void CBaseMonster::set_state_sound(u32 type, bool once)
{
	if (once) {
	
		sound().play(type);
	
	} else {

		// handle situation, when monster want to play attack sound for the first time
		if ((type == MonsterSound::eMonsterSoundAggressive) && 
			(m_prev_sound_type != MonsterSound::eMonsterSoundAggressive)) {
			
			sound().play(MonsterSound::eMonsterSoundAttackHit);

		} else {
			// get count of monsters in squad
			u8 objects_count = monster_squad().get_squad(this)->get_count(this, 20.f);

			// include myself
			objects_count++;
			VERIFY(objects_count > 0);

			u32 delay = 0;
			switch (type) {
			case MonsterSound::eMonsterSoundIdle : 
				// check distance to actor

				if (Actor()->Position().distance_to(Position()) > db().m_fDistantIdleSndRange) {
					delay = u32(float(db().m_dwDistantIdleSndDelay) * _sqrt(float(objects_count)));
					type  = MonsterSound::eMonsterSoundIdleDistant;
				} else {
					delay = u32(float(db().m_dwIdleSndDelay) * _sqrt(float(objects_count)));
				}
				
				break;
			case MonsterSound::eMonsterSoundEat:
				delay = u32(float(db().m_dwEatSndDelay) * _sqrt(float(objects_count)));
				break;
			case MonsterSound::eMonsterSoundAggressive:
			case MonsterSound::eMonsterSoundPanic:
				delay = u32(float(db().m_dwAttackSndDelay) * _sqrt(float(objects_count)));
				break;
			}

			sound().play(type, 0, 0, delay);
		} 
	}

	m_prev_sound_type	= type;
}

BOOL CBaseMonster::feel_touch_on_contact	(CObject *O)
{
	return		(inherited::feel_touch_on_contact(O));
}

BOOL CBaseMonster::feel_touch_contact(CObject *O)
{
	m_anomaly_detector->on_contact(O);
	return inherited::feel_touch_contact(O);
}

void CBaseMonster::TranslateActionToPathParams()
{
	bool bEnablePath = true;
	u32 vel_mask = 0;
	u32 des_mask = 0;

	switch (anim().m_tAction) {
	case ACT_STAND_IDLE: 
	case ACT_SIT_IDLE:	 
	case ACT_LIE_IDLE:
	case ACT_EAT:
	case ACT_SLEEP:
	case ACT_REST:
	case ACT_LOOK_AROUND:
	case ACT_ATTACK:
		bEnablePath = false;
		break;

	case ACT_WALK_FWD:
		if (m_bDamaged) {
			vel_mask = MonsterMovement::eVelocityParamsWalkDamaged;
			des_mask = MonsterMovement::eVelocityParameterWalkDamaged;
		} else {
			vel_mask = MonsterMovement::eVelocityParamsWalk;
			des_mask = MonsterMovement::eVelocityParameterWalkNormal;
		}
		break;
	case ACT_WALK_BKWD:
		break;
	case ACT_RUN:
		if (m_bDamaged) {
			vel_mask = MonsterMovement::eVelocityParamsRunDamaged;
			des_mask = MonsterMovement::eVelocityParameterRunDamaged;
		} else {
			vel_mask = MonsterMovement::eVelocityParamsRun;
			des_mask = MonsterMovement::eVelocityParameterRunNormal;
		}
		break;
	case ACT_DRAG:
		vel_mask = MonsterMovement::eVelocityParamsDrag;
		des_mask = MonsterMovement::eVelocityParameterDrag;

		anim().SetSpecParams(ASP_MOVE_BKWD);

		break;
	case ACT_STEAL:
		vel_mask = MonsterMovement::eVelocityParamsSteal;
		des_mask = MonsterMovement::eVelocityParameterSteal;
		break;
	}

	if (state_invisible) {
		vel_mask = MonsterMovement::eVelocityParamsInvisible;
		des_mask = MonsterMovement::eVelocityParameterInvisible;
	}

	if (m_force_real_speed) vel_mask = des_mask;

	if (bEnablePath) {
		path().set_velocity_mask	(vel_mask);
		path().set_desirable_mask	(des_mask);
		path().enable_path			();
	} else {
		path().disable_path			();
	}
}

u32 CBaseMonster::get_attack_rebuild_time()
{
	float dist = EnemyMan.get_enemy()->Position().distance_to(Position());
	return (100 + u32(50.f * dist));
}

void CBaseMonster::on_kill_enemy(const CEntity *obj)
{
	const CEntityAlive *entity	= smart_cast<const CEntityAlive *>(obj);
	
	// добавить в список трупов	
	CorpseMemory.add_corpse		(entity);
	
	// удалить всю информацию о хитах
	HitMemory.remove_hit_info	(entity);

	// удалить всю информацию о звуках
	SoundMemory.clear			();
}

CMovementManager *CBaseMonster::create_movement_manager	()
{
	m_movement_manager = new CControlPathBuilder(this);

	control().add					(m_movement_manager, ControlCom::eControlPath);
	control().install_path_manager	(m_movement_manager);
	control().set_base_controller	(m_path_base, ControlCom::eControlPath);

	return			(m_movement_manager);
}

DLL_Pure *CBaseMonster::_construct	()
{
	create_base_controls			();

	control().add					(m_anim_base, ControlCom::eControlAnimationBase);
	control().add					(m_move_base, ControlCom::eControlMovementBase);
	control().add					(m_path_base, ControlCom::eControlPathBase);
	control().add					(m_dir_base,  ControlCom::eControlDirBase);

	control().set_base_controller	(m_anim_base, ControlCom::eControlAnimation);
	control().set_base_controller	(m_move_base, ControlCom::eControlMovement);
	control().set_base_controller	(m_dir_base,  ControlCom::eControlDir);
	
	inherited::_construct		();
	CStepManager::_construct	();
	CInventoryOwner::_construct	();
	return						(this);
}

void CBaseMonster::net_Relcase(CObject *O)
{
	inherited::net_Relcase(O);

	// TODO: do not clear, remove only object O
	if (g_Alive()) {
		EnemyMemory.remove_links	(O);
		SoundMemory.remove_links	(O);
		CorpseMemory.remove_links	(O);
		HitMemory.remove_hit_info	(O);

		EnemyMan.reinit				();
		CorpseMan.reinit			();

		UpdateMemory				();
		
		monster_squad().remove_links(O);
	}
	m_pPhysics_support->in_NetRelcase(O);
}
	
void CBaseMonster::create_base_controls()
{
	m_anim_base		= new CControlAnimationBase();
	m_move_base		= new CControlMovementBase();
	m_path_base		= new CControlPathBuilderBase();
	m_dir_base		= new CControlDirectionBase();
}

void CBaseMonster::set_action(EAction action)
{
	anim().m_tAction		= action;
}

CParticlesObject* CBaseMonster::PlayParticles(const shared_str& name, const Fvector &position, const Fvector &dir, BOOL auto_remove, BOOL xformed)
{
	CParticlesObject* ps = CParticlesObject::Create(name.c_str(),auto_remove);
	
	// вычислить позицию и направленность партикла
	Fmatrix	matrix; 

	matrix.identity			();
	matrix.k.set			(dir);
	Fvector::generate_orthonormal_basis_normalized(matrix.k,matrix.j,matrix.i);
	matrix.translate_over	(position);
	
	(xformed) ?				ps->SetXFORM (matrix) : ps->UpdateParent(matrix,zero_vel); 
	ps->Play				(false);

	return ps;
}

void CBaseMonster::on_restrictions_change()
{
	inherited::on_restrictions_change();

	if (StateMan) StateMan->reinit();
}

void CBaseMonster::load_effector(LPCSTR section, LPCSTR line, SAttackEffector &effector)
{
	LPCSTR ppi_section = pSettings->r_string(section, line);
	effector.ppi.duality.h			= pSettings->r_float(ppi_section,"duality_h");
	effector.ppi.duality.v			= pSettings->r_float(ppi_section,"duality_v");
	effector.ppi.gray				= pSettings->r_float(ppi_section,"gray");
	effector.ppi.blur				= pSettings->r_float(ppi_section,"blur");
	effector.ppi.noise.intensity	= pSettings->r_float(ppi_section,"noise_intensity");
	effector.ppi.noise.grain		= pSettings->r_float(ppi_section,"noise_grain");
	effector.ppi.noise.fps			= pSettings->r_float(ppi_section,"noise_fps");
	VERIFY(!fis_zero(effector.ppi.noise.fps));

	sscanf(pSettings->r_string(ppi_section,"color_base"),	"%f,%f,%f", &effector.ppi.color_base.r,	&effector.ppi.color_base.g,	&effector.ppi.color_base.b);
	sscanf(pSettings->r_string(ppi_section,"color_gray"),	"%f,%f,%f", &effector.ppi.color_gray.r,	&effector.ppi.color_gray.g,	&effector.ppi.color_gray.b);
	sscanf(pSettings->r_string(ppi_section,"color_add"),	"%f,%f,%f", &effector.ppi.color_add.r,	&effector.ppi.color_add.g,	&effector.ppi.color_add.b);

	effector.time				= pSettings->r_float(ppi_section,"time");
	effector.time_attack		= pSettings->r_float(ppi_section,"time_attack");
	effector.time_release		= pSettings->r_float(ppi_section,"time_release");

	effector.ce_time			= pSettings->r_float(ppi_section,"ce_time");
	effector.ce_amplitude		= pSettings->r_float(ppi_section,"ce_amplitude");
	effector.ce_period_number	= pSettings->r_float(ppi_section,"ce_period_number");
	effector.ce_power			= pSettings->r_float(ppi_section,"ce_power");
}

bool CBaseMonster::check_start_conditions(ControlCom::EControlType type)
{
	if (type == ControlCom::eControlRotationJump) {
		EMonsterState state = StateMan->get_state_type();
		if (state != eStateAttack_Run) return false;
	} if (type == ControlCom::eControlMeleeJump) {
		EMonsterState state = StateMan->get_state_type();
		if (!is_state(state, eStateAttack_Run) && !is_state(state, eStateAttack_Melee)) return false;
	}
	return true;
}

void CBaseMonster::OnEvent(NET_Packet& P, u16 type)
{
	inherited::OnEvent			(P,type);
	CInventoryOwner::OnEvent	(P,type);

	u16			id;
	switch (type){
	case GE_OWNERSHIP_TAKE:
		{
			P.r_u16		(id);
			bool duringSpawn = !P.r_eof() && P.r_u8();
			CObject		*O	= Level().Objects.net_Find	(id);
			VERIFY		(O);

			CGameObject			*GO = smart_cast<CGameObject*>(O);
			CInventoryItem		*pIItem = smart_cast<CInventoryItem*>(GO);
			VERIFY				(inventory().CanTakeItem(pIItem));
			pIItem->SetCurrPlace(eItemPlaceRuck);

			O->H_SetParent		(this);
			inventory().Take	(GO, true, true, duringSpawn);
		break;
		}
	case GE_TRADE_SELL:

	case GE_OWNERSHIP_REJECT:
		{
			P.r_u16		(id);
			CObject* O	= Level().Objects.net_Find	(id);
			VERIFY		(O);

			bool just_before_destroy	= !P.r_eof() && P.r_u8();
			O->SetTmpPreDestroy				(just_before_destroy);
			if (inventory().DropItem(smart_cast<CGameObject*>(O)) && !O->getDestroy()) 
			{
				O->H_SetParent	(0,just_before_destroy);
				feel_touch_deny	(O,2000);
			}
		}
		break;

	case GE_KILL_SOMEONE:
		P.r_u16		(id);
		CObject* O	= Level().Objects.net_Find	(id);

		if (O)  {
			CEntity *pEntity = smart_cast<CEntity*>(O);
			if (pEntity) on_kill_enemy(pEntity);
		}
			
		break;
	}
}

bool CBaseMonster::psy_aura_enabled_for_dead() const
{
	return m_psy_aura.is_enabled_for_dead();
}

bool CBaseMonster::radiation_aura_enabled_for_dead() const
{
	return m_radiation_aura.is_enabled_for_dead();
}

bool CBaseMonster::fire_aura_enabled_for_dead() const
{
	return m_fire_aura.is_enabled_for_dead();
}

bool CBaseMonster::shock_aura_enabled_for_dead() const
{
	return m_shock_aura.is_enabled_for_dead();
}

bool CBaseMonster::chemical_aura_enabled_for_dead() const
{
	return m_chemical_aura.is_enabled_for_dead();
}

bool CBaseMonster::biological_aura_enabled_for_dead() const
{
	return m_biological_aura.is_enabled_for_dead();
}

float CBaseMonster::get_psy_aura_influence()
{
	return m_psy_aura.calculate();
}

float CBaseMonster::get_radiation_aura_influence()
{
	return m_radiation_aura.calculate();
}

float CBaseMonster::get_fire_aura_influence()
{
	return m_fire_aura.calculate();
}

float CBaseMonster::get_shock_aura_influence()
{
	return m_shock_aura.calculate();
}

float CBaseMonster::get_chemical_aura_influence()
{
	return m_chemical_aura.calculate();
}

float CBaseMonster::get_biological_aura_influence()
{
	return m_biological_aura.calculate();
}

void CBaseMonster::play_detector_sound()
{
	m_psy_aura.play_detector_sound();
	m_radiation_aura.play_detector_sound();
	m_fire_aura.play_detector_sound();
	m_shock_aura.play_detector_sound();
	m_chemical_aura.play_detector_sound();
	m_biological_aura.play_detector_sound();
}



// Установка анимации
void CBaseMonster::SelectAnimation(const Fvector &/**_view/**/, const Fvector &/**_move/**/, float /**speed/**/)
{
	control().animation().update_frame();
}

#ifdef DEBUG
CBaseMonster::SDebugInfo CBaseMonster::show_debug_info()
{
	if (!g_Alive()) return SDebugInfo();

	if (m_show_debug_info == 0) {
		DBG().text(this).clear();
		return SDebugInfo();
	}

	float y				= 200;
	float x				= (m_show_debug_info == 1) ? 40.f : float(::Render->getTarget()->get_width() / 2) + 40.f;
	const float delta_y	= 12;

	string256	text;

	u32			color			= D3DCOLOR_XRGB(0,255,0);
	u32			delimiter_color	= D3DCOLOR_XRGB(0,0,255);

	DBG().text(this).clear	 ();
	DBG().text(this).add_item("---------------------------------------", x, y+=delta_y, delimiter_color);

	xr_sprintf(text, "-- Monster : [%s]  Current Time = [%u]", *cName(), Device.dwTimeGlobal);
	DBG().text(this).add_item(text, x, y+=delta_y, color);
	DBG().text(this).add_item("-----------   PROPERTIES   ------------", x, y+=delta_y, delimiter_color);

	xr_sprintf(text, "Health = [%f]", conditions().GetHealth());
	DBG().text(this).add_item(text,										 x, y+=delta_y, color);

	xr_sprintf(text, "Morale = [%f]", Morale.get_morale());
	DBG().text(this).add_item(text,										 x, y+=delta_y, color);


	DBG().text(this).add_item("-----------   MEMORY   ----------------", x, y+=delta_y, delimiter_color);

	if (EnemyMan.get_enemy()) {
		xr_sprintf(text, "Current Enemy = [%s]", *EnemyMan.get_enemy()->cName());
	} else 
		xr_sprintf(text, "Current Enemy = [NONE]");
	DBG().text(this).add_item(text,										 x, y+=delta_y, color);
	
	if (EnemyMan.get_enemy()) {
		xr_sprintf(text, "SeeEnemy[%u] EnemySeeMe[%u] TimeLastSeen[%u]", EnemyMan.see_enemy_now(),EnemyMan.enemy_see_me_now(),EnemyMan.get_enemy_time_last_seen());
		DBG().text(this).add_item(text,									x, y+=delta_y, color);
	}

	if (CorpseMan.get_corpse()) {
		xr_sprintf(text, "Current Corpse = [%s] Satiety = [%.2f]", *CorpseMan.get_corpse()->cName(), GetSatiety());
	} else 
		xr_sprintf(text, "Current Corpse = [NONE] Satiety = [%.2f]", GetSatiety());

	DBG().text(this).add_item(text,										 x, y+=delta_y, color);

	// Sound
	if (SoundMemory.IsRememberSound()) {
		SoundElem	sound_elem;
		bool		dangerous_sound;
		SoundMemory.GetSound(sound_elem, dangerous_sound);

		string128	s_type;

		switch(sound_elem.type){
			case WEAPON_SHOOTING:			xr_strcpy(s_type,"WEAPON_SHOOTING"); break;
			case MONSTER_ATTACKING:			xr_strcpy(s_type,"MONSTER_ATTACKING"); break;
			case WEAPON_BULLET_RICOCHET:	xr_strcpy(s_type,"WEAPON_BULLET_RICOCHET"); break;
			case WEAPON_RECHARGING:			xr_strcpy(s_type,"WEAPON_RECHARGING"); break;

			case WEAPON_TAKING:				xr_strcpy(s_type,"WEAPON_TAKING"); break;
			case WEAPON_HIDING:				xr_strcpy(s_type,"WEAPON_HIDING"); break;
			case WEAPON_CHANGING:			xr_strcpy(s_type,"WEAPON_CHANGING"); break;
			case WEAPON_EMPTY_CLICKING:		xr_strcpy(s_type,"WEAPON_EMPTY_CLICKING"); break;

			case MONSTER_DYING:				xr_strcpy(s_type,"MONSTER_DYING"); break;
			case MONSTER_INJURING:			xr_strcpy(s_type,"MONSTER_INJURING"); break;
			case MONSTER_WALKING:			xr_strcpy(s_type,"MONSTER_WALKING"); break;
			case MONSTER_JUMPING:			xr_strcpy(s_type,"MONSTER_JUMPING"); break;
			case MONSTER_FALLING:			xr_strcpy(s_type,"MONSTER_FALLING"); break;
			case MONSTER_TALKING:			xr_strcpy(s_type,"MONSTER_TALKING"); break;

			case DOOR_OPENING:				xr_strcpy(s_type,"DOOR_OPENING"); break;
			case DOOR_CLOSING:				xr_strcpy(s_type,"DOOR_CLOSING"); break;
			case OBJECT_BREAKING:			xr_strcpy(s_type,"OBJECT_BREAKING"); break;
			case OBJECT_FALLING:			xr_strcpy(s_type,"OBJECT_FALLING"); break;
			case NONE_DANGEROUS_SOUND:		xr_strcpy(s_type,"NONE_DANGEROUS_SOUND"); break;
		}

		if (sound_elem.who)
			xr_sprintf(text,"Sound: type[%s] time[%u] power[%.3f] val[%i] src[+]", s_type, sound_elem.time, sound_elem.power, sound_elem.value);
		else 
			xr_sprintf(text,"Sound: type[%s] time[%u] power[%.3f] val[%i] src[?]", s_type, sound_elem.time, sound_elem.power, sound_elem.value);


	} else 
		xr_sprintf(text, "Sound: NONE");

	DBG().text(this).add_item(text,										 x, y+=delta_y, color);

	// Hit
	if (HitMemory.is_hit()) {
		if (HitMemory.get_last_hit_object()) {
			xr_sprintf(text,"Hit Info: object=[%s] time=[%u]", *(HitMemory.get_last_hit_object()->cName()), HitMemory.get_last_hit_time());
		} else {
			xr_sprintf(text,"Hit Info: object=[NONE] time=[%u]", HitMemory.get_last_hit_time());
		}
	} else 
		xr_sprintf(text, "Hit Info: NONE");

	DBG().text(this).add_item(text,										 x, y+=delta_y, color);

	DBG().text(this).add_item("-----------   MOVEMENT   ------------", x, y+=delta_y, delimiter_color);

	xr_sprintf(text, "Actual = [%u] Enabled = [%u]",			 control().path_builder().actual(), control().path_builder().enabled());
	DBG().text(this).add_item(text,										x, y+=delta_y, color);
	
	xr_sprintf(text, "Speed: Linear = [%.3f] Angular = [%.3f]", control().movement().velocity_current(), 0.f);
	DBG().text(this).add_item(text,										x, y+=delta_y, color);
	
	DBG().text(this).add_item("------- Attack Distances -------------", x, y+=delta_y, delimiter_color);
	xr_sprintf(text, "MinDist[%.3f] MaxDist[%.3f] As_Step[%.3f] As_MinDist[%.3f]", 
		MeleeChecker.get_min_distance(),
		MeleeChecker.get_max_distance(),
		MeleeChecker.dbg_as_step(),
		MeleeChecker.dbg_as_min_dist()
	);
	DBG().text(this).add_item(text,										x, y+=delta_y, color);


	if (EnemyMan.get_enemy()) {
		xr_sprintf(text, "Current Enemy = [%s]", *EnemyMan.get_enemy()->cName());
	} else 
		xr_sprintf(text, "Current Enemy = [NONE]");
	DBG().text(this).add_item(text,										 x, y+=delta_y, color);



	return SDebugInfo(x, y, delta_y, color, delimiter_color);
}

void CBaseMonster::debug_fsm()
{
	if (!g_Alive()) return;

	if (!psAI_Flags.test(aiMonsterDebug)) {
		DBG().object_info(this,this).clear ();
		return;
	}
	
	EMonsterState state = StateMan->get_state_type();
	
	string128 st;

	switch (state) {
		case eStateRest_WalkGraphPoint:					xr_sprintf(st,"Rest :: Walk Graph");			break;
		case eStateRest_Idle:							xr_sprintf(st,"Rest :: Idle");					break;
		case eStateRest_Fun:							xr_sprintf(st,"Rest :: Fun");					break;
		case eStateRest_Sleep:							xr_sprintf(st,"Rest :: Sleep");				break;
		case eStateRest_MoveToHomePoint:				xr_sprintf(st,"Rest :: MoveToHomePoint");		break;
		case eStateRest_WalkToCover:					xr_sprintf(st,"Rest :: WalkToCover");			break;
		case eStateRest_LookOpenPlace:					xr_sprintf(st,"Rest :: LookOpenPlace");		break;

		case eStateEat_CorpseApproachRun:				xr_sprintf(st,"Eat :: Corpse Approach Run");	break;
		case eStateEat_CorpseApproachWalk:				xr_sprintf(st,"Eat :: Corpse Approach Walk");	break;
		case eStateEat_CheckCorpse:						xr_sprintf(st,"Eat :: Check Corpse");			break;
		case eStateEat_Eat:								xr_sprintf(st,"Eat :: Eating");				break;
		case eStateEat_WalkAway:						xr_sprintf(st,"Eat :: Walk Away");				break;
		case eStateEat_Rest:							xr_sprintf(st,"Eat :: Rest After Meal");		break;
		case eStateEat_Drag:							xr_sprintf(st,"Eat :: Drag");					break;
		
		case eStateAttack_Run:							xr_sprintf(st,"Attack :: Run");				break;
		case eStateAttack_Melee:						xr_sprintf(st,"Attack :: Melee");				break;
		case eStateAttack_RunAttack:					xr_sprintf(st,"Attack :: Run Attack");			break;
		case eStateAttack_RunAway:						xr_sprintf(st,"Attack :: Run Away");			break;
		case eStateAttack_FindEnemy:					xr_sprintf(st,"Attack :: Find Enemy");			break;
		case eStateAttack_Steal:						xr_sprintf(st,"Attack :: Steal");				break;
		case eStateAttack_AttackHidden:					xr_sprintf(st,"Attack :: Attack Hidden");		break;
		
		case eStateAttackCamp_Hide:						xr_sprintf(st,"Attack Camp:: Hide");			break;
		case eStateAttackCamp_Camp:						xr_sprintf(st,"Attack Camp:: Camp");			break;
		case eStateAttackCamp_StealOut:					xr_sprintf(st,"Attack Camp:: Steal Out");		break;

		case eStateAttack_HideInCover:					xr_sprintf(st,"Attack :: Hide In Cover");		break;
		case eStateAttack_MoveOut:						xr_sprintf(st,"Attack :: Move Out From Cover");break;
		case eStateAttack_CampInCover:					xr_sprintf(st,"Attack :: Camp In Cover");		break;

		case eStateAttack_Psy:							xr_sprintf(st,"Attack :: Psy");				break;
		case eStateAttack_MoveToHomePoint:				xr_sprintf(st,"Attack :: Move To Home Point");	break;
		case eStateAttack_HomePoint_Hide:				xr_sprintf(st,"Attack :: Home Point :: Hide");	break;
		case eStateAttack_HomePoint_Camp:				xr_sprintf(st,"Attack :: Home Point :: Camp");	break;
		case eStateAttack_HomePoint_LookOpenPlace:		xr_sprintf(st,"Attack :: Home Point :: Look Open Place");	break;
		
		case eStatePanic_Run:							xr_sprintf(st,"Panic :: Run Away");				break;
		case eStatePanic_FaceUnprotectedArea:			xr_sprintf(st,"Panic :: Face Unprotected Area");	break;
		case eStatePanic_HomePoint_Hide:				xr_sprintf(st,"Panic :: Home Point :: Hide");		break;
		case eStatePanic_HomePoint_LookOpenPlace:		xr_sprintf(st,"Panic :: Home Point :: Look Open Place");	break;
		case eStatePanic_HomePoint_Camp:				xr_sprintf(st,"Panic :: Home Point :: Camp");		break;

		case eStateHitted_Hide:							xr_sprintf(st,"Hitted :: Hide");					break;
		case eStateHitted_MoveOut:						xr_sprintf(st,"Hitted :: MoveOut");				break;
		case eStateHitted_Home:							xr_sprintf(st,"Hitted :: Home");				break;

		case eStateHearDangerousSound_Hide:				xr_sprintf(st,"Dangerous Snd :: Hide");			break;
		case eStateHearDangerousSound_FaceOpenPlace:	xr_sprintf(st,"Dangerous Snd :: FaceOpenPlace");	break;
		case eStateHearDangerousSound_StandScared:		xr_sprintf(st,"Dangerous Snd :: StandScared");		break;
		case eStateHearDangerousSound_Home:				xr_sprintf(st,"Dangerous Snd :: Home");			break;

		case eStateHearInterestingSound_MoveToDest:		xr_sprintf(st,"Interesting Snd :: MoveToDest");	break;
		case eStateHearInterestingSound_LookAround:		xr_sprintf(st,"Interesting Snd :: LookAround");	break;
		
		case eStateHearHelpSound:						xr_sprintf(st,"Hear Help Sound");	break;
		case eStateHearHelpSound_MoveToDest:			xr_sprintf(st,"Hear Help Sound :: MoveToDest");	break;
		case eStateHearHelpSound_LookAround:			xr_sprintf(st,"Hear Help Sound :: LookAround");	break;

		case eStateControlled_Follow_Wait:				xr_sprintf(st,"Controlled :: Follow : Wait");			break;
		case eStateControlled_Follow_WalkToObject:		xr_sprintf(st,"Controlled :: Follow : WalkToObject");	break;
		case eStateControlled_Attack:					xr_sprintf(st,"Controlled :: Attack");					break;
		case eStateThreaten:							xr_sprintf(st,"Threaten :: ");							break;
		case eStateFindEnemy_Run:						xr_sprintf(st,"Find Enemy :: Run");							break;
		case eStateFindEnemy_LookAround_MoveToPoint:	xr_sprintf(st,"Find Enemy :: Look Around : Move To Point");	break;
		case eStateFindEnemy_LookAround_LookAround:		xr_sprintf(st,"Find Enemy :: Look Around : Look Around");		break;
		case eStateFindEnemy_LookAround_TurnToPoint:	xr_sprintf(st,"Find Enemy :: Look Around : Turn To Point");	break;
		case eStateFindEnemy_Angry:						xr_sprintf(st,"Find Enemy :: Angry");							break;
		case eStateFindEnemy_WalkAround:				xr_sprintf(st,"Find Enemy :: Walk Around");					break;
		case eStateSquad_Rest_Idle:						xr_sprintf(st,"Squad :: Rest : Idle");					break;
		case eStateSquad_Rest_WalkAroundLeader:			xr_sprintf(st,"Squad :: Rest : WalkAroundLeader");		break;
		case eStateSquad_RestFollow_Idle:				xr_sprintf(st,"Squad :: Follow Leader : Idle");		break;
		case eStateSquad_RestFollow_WalkToPoint:		xr_sprintf(st,"Squad :: Follow Leader : WalkToPoint");	break;
		case eStateCustom_Vampire:						xr_sprintf(st,"Attack :: Vampire");					break;
		case eStateVampire_ApproachEnemy:				xr_sprintf(st,"Vampire :: Approach to enemy");			break;
		case eStateVampire_Execute:						xr_sprintf(st,"Vampire :: Hit");						break;
		case eStateVampire_RunAway:						xr_sprintf(st,"Vampire :: Run Away");					break;
		case eStateVampire_Hide:						xr_sprintf(st,"Vampire :: Hide");						break;
		case eStatePredator:							xr_sprintf(st,"Predator");								break;
		case eStatePredator_MoveToCover:				xr_sprintf(st,"Predator :: MoveToCover");				break;
		case eStatePredator_LookOpenPlace:				xr_sprintf(st,"Predator :: Look Open Place");			break;
		case eStatePredator_Camp:						xr_sprintf(st,"Predator :: Camp");						break;
		case eStateBurerAttack_Tele:					xr_sprintf(st,"Attack :: Telekinesis");			break;
		case eStateBurerAttack_Gravi:					xr_sprintf(st,"Attack :: Gravi Wave");				break;
		case eStateBurerAttack_RunAround:				xr_sprintf(st,"Attack :: Run Around");			break;
		case eStateBurerAttack_FaceEnemy:				xr_sprintf(st,"Attack :: Face Enemy");			break;
		case eStateBurerAttack_Melee:					xr_sprintf(st,"Attack :: Melee");				break;
		case eStateBurerScanning:						xr_sprintf(st,"Attack :: Scanning");			break;
		case eStateGhostBossAttack_Tele:				xr_sprintf(st,"GhostBoss::Attack :: Telekinesis");			break;
		case eStateGhostBossAttack_Gravi:				xr_sprintf(st,"GhostBoss::Attack :: Gravi Wave");				break;
		case eStateGhostBossAttack_RunAround:			xr_sprintf(st,"GhostBoss::Attack :: Run Around");			break;
		case eStateGhostBossAttack_FaceEnemy:			xr_sprintf(st,"GhostBoss::Attack :: Face Enemy");			break;
		case eStateGhostBossAttack_Melee:				xr_sprintf(st,"GhostBoss::Attack :: Melee");				break;
		case eStateGhostBossScanning:					xr_sprintf(st,"GhostBoss::Attack :: Scanning");			break;
		case eStateCustomMoveToRestrictor:				xr_sprintf(st,"Moving To Restrictor :: Position not accessible");	break;
		case eStateSmartTerrainTask:					xr_sprintf(st,"ALIFE");	break;
		case eStateSmartTerrainTaskGamePathWalk:		xr_sprintf(st,"ALIFE :: Game Path Walk");	break;
		case eStateSmartTerrainTaskLevelPathWalk:		xr_sprintf(st,"ALIFE :: Level Path Walk");	break;
		case eStateSmartTerrainTaskWaitCapture:			xr_sprintf(st,"ALIFE :: Wait till smart terrain will capture me");	break;
		case eStateUnknown:								xr_sprintf(st,"Unknown State :: ");			break;
		default:										xr_sprintf(st,"Undefined State ::");			break;
	}
	
	DBG().object_info(this,this).remove_item (u32(0));
	DBG().object_info(this,this).remove_item (u32(1));
	DBG().object_info(this,this).remove_item (u32(2));

	DBG().object_info(this,this).add_item	 (*cName(), D3DCOLOR_XRGB(255,0,0), 0);
	DBG().object_info(this,this).add_item	 (st, D3DCOLOR_XRGB(255,0,0), 1);
	
	xr_sprintf(st, "Team[%u]Squad[%u]Group[%u]", g_Team(), g_Squad(), g_Group());
	DBG().object_info(this,this).add_item	 (st, D3DCOLOR_XRGB(255,0,0), 2);

	CEntityAlive *entity = smart_cast<CEntityAlive *>(Level().CurrentEntity());
	if (entity && entity->character_physics_support()->movement()) {
		xr_sprintf(st,"VELOCITY [%f,%f,%f] Value[%f]",VPUSH(entity->character_physics_support()->movement()->GetVelocity()),entity->character_physics_support()->movement()->GetVelocityActual());
		DBG().text(this).clear();
		DBG().text(this).add_item(st,200,100,COLOR_GREEN,100);
	}
}


#endif


////////////////////////////////////////////////////////////////////////////
//	Description : Visibility and look for all the biting monsters
////////////////////////////////////////////////////////////////////////////

void CBaseMonster::feel_sound_new(CObject* who, int eType, CSound_UserDataPtr user_data, const Fvector &Position, float power)
{
	if (!g_Alive())		return;

	// ignore my sounds
	if (this == who)	return;

	if (user_data)
		user_data->accept	(sound_user_data_visitor());

	// ignore unknown sounds
	if (eType == 0xffffffff) return;

	// ignore distant sounds
	Fvector center;
	Center	(center);
	float dist	= center.distance_to(Position);
	if (dist > db().m_max_hear_dist)	return;

	// ignore sounds if not from enemies and not help sounds
	CEntityAlive* entity = smart_cast<CEntityAlive*> (who);

	// ignore sound if enemy drop a weapon on death
	if (!entity && ((eType & SOUND_TYPE_ITEM_HIDING) == SOUND_TYPE_ITEM_HIDING)) return;

	if (entity && (!EnemyMan.is_enemy(entity))) {
		SoundMemory.check_help_sound(eType, entity->ai_location().level_vertex_id());
		return;
	}
	
	if ((eType & SOUND_TYPE_WEAPON_SHOOTING) == SOUND_TYPE_WEAPON_SHOOTING) power = 1.f;

	if (((eType & SOUND_TYPE_WEAPON_BULLET_HIT) == SOUND_TYPE_WEAPON_BULLET_HIT) && (dist < 2.f)) 
		HitMemory.add_hit(who,eSideFront);

	// execute callback
	sound_callback	(who,eType,Position,power);
	
	// register in sound memory
	if (power >= db().m_fSoundThreshold) {
		SoundMemory.HearSound(who,eType,Position,power,Device.dwTimeGlobal);
 	}
}
#define MAX_LOCK_TIME 2.f

void CBaseMonster::HitEntity(const CEntity* pEntity, float fDamage, float impulse, Fvector& dir, ALife::EHitType hit_type, LPCSTR hit_mark, bool use_secodary)
{
	if (!g_Alive()) return;
	if (!pEntity || pEntity->getDestroy()) return;
	if (!EnemyMan.get_enemy()) return;

	if (EnemyMan.get_enemy() == pEntity) {
		Fvector position_in_bone_space;
		position_in_bone_space.set(0.f,0.f,0.f);

		// перевод из локальных координат в мировые вектора направления импульса
		Fvector hit_dir;
		XFORM().transform_dir	(hit_dir,dir);
		hit_dir.normalize		();

		CEntity		*pEntityNC	= const_cast<CEntity*>(pEntity);
		VERIFY		(pEntityNC);
		
		NET_Packet	l_P;
		SHit		HS;
		HS.GenHeader(GE_HIT, pEntityNC->ID());													//		u_EventGen	(l_P,GE_HIT, pEntityNC->ID());
		HS.whoID			= (ID());															//		l_P.w_u16	(ID());
		HS.weaponID			= (ID());															//		l_P.w_u16	(ID());
		HS.dir				= (hit_dir);														//		l_P.w_dir	(hit_dir);
		HS.power			= (fDamage*hit_power);												//		l_P.w_float	(fDamage);
		HS.boneID			= (smart_cast<IKinematics*>(pEntityNC->Visual())->LL_GetBoneRoot());//		l_P.w_s16	(smart_cast<IKinematics*>(pEntityNC->Visual())->LL_GetBoneRoot());
		HS.p_in_bone_space	= (position_in_bone_space);											//		l_P.w_vec3	(position_in_bone_space);
		HS.impulse			= (impulse);														//		l_P.w_float	(impulse);
		HS.hit_type			= (hit_type);											//		l_P.w_u16	( u16(ALife::eHitTypeWound) );
		HS.use_secondary	= (use_secodary);
		HS.Write_Packet(l_P);
		u_EventSend	(l_P);
		if (pEntityNC == Actor()) {
				START_PROFILE("BaseMonster/Animation/HitEntity");
				SDrawStaticStruct* s = CurrentGameUI()->AddCustomStatic(hit_mark, false, 3.0f);

				float h1, p1;
				Device.vCameraDirection.getHP(h1, p1);

				Fvector hd = hit_dir;
				hd.mul(-1);
				float d = -h1 + hd.getH();
				s->wnd()->SetHeading(d);
				s->wnd()->SetHeadingPivot(Fvector2().set(256, 512), Fvector2().set(0, 0), false);

				STOP_PROFILE;

			SetAttackEffector			();
			
			float time_to_lock		= fDamage * hit_power * MAX_LOCK_TIME;
			clamp					(time_to_lock, 0.f, MAX_LOCK_TIME);
			Actor()->lock_accel_for	(int(time_to_lock * 1000));
		}

		Morale.on_attack_success();
		
		m_time_last_attack_success	= Device.dwTimeGlobal;
	}
}


BOOL  CBaseMonster::feel_vision_isRelevant(CObject* O)
{
	if (!g_Alive())					return FALSE;
	if (0==smart_cast<CEntity*>(O))	return FALSE;
	
	if ((O->spatial.type & STYPE_VISIBLEFORAI) != STYPE_VISIBLEFORAI) return FALSE;
	
	// если спит, то ничего не видит
	if (m_bSleep) return FALSE;
	
	// если не враг - не видит
	CEntityAlive* entity = smart_cast<CEntityAlive*> (O);
	if (entity && entity->g_Alive()) {
		if (!EnemyMan.is_enemy(entity)) {
			// если видит друга - проверить наличие у него врагов
			CBaseMonster *monster = smart_cast<CBaseMonster *>(entity);
			if (monster && !m_skip_transfer_enemy) EnemyMan.transfer_enemy(monster);
			return FALSE;
		}
	}

	return TRUE;
}

void CBaseMonster::HitSignal(float amount, Fvector& vLocalDir, CObject* who, s16 element)
{
	if (!g_Alive()) return;
	
	feel_sound_new(who,SOUND_TYPE_WEAPON_SHOOTING,0,who->Position(),1.f);
	if (g_Alive()) sound().play(MonsterSound::eMonsterSoundTakeDamage);

	if (element < 0) return;

	// Определить направление хита (перед || зад || лево || право)
	float yaw,pitch;
	vLocalDir.getHP(yaw,pitch);
	
	yaw = angle_normalize(yaw);
	
	EHitSide hit_side = eSideFront;
	if ((yaw >= PI_DIV_4) && (yaw <= 3*PI_DIV_4)) hit_side = eSideLeft;
	else if ((yaw >= 3 * PI_DIV_4) && (yaw <= 5*PI_DIV_4)) hit_side = eSideBack;
	else if ((yaw >= 5 * PI_DIV_4) && (yaw <= 7*PI_DIV_4)) hit_side = eSideRight;

	anim().FX_Play	(hit_side, 1.0f);

	HitMemory.add_hit	(who,hit_side);

	Morale.on_hit		();

	callback(GameObject::eHit)(
		lua_game_object(), 
		amount,
		vLocalDir,
		smart_cast<const CGameObject*>(who)->lua_game_object(),
		element
	);

	// если нейтрал - добавить как врага
	CEntityAlive	*obj = smart_cast<CEntityAlive*>(who);
	if (obj && (tfGetRelationType(obj) == ALife::eRelationTypeNeutral)) EnemyMan.add_enemy(obj);
}

void CBaseMonster::SetAttackEffector() 
{
	CActor *pA = smart_cast<CActor *>(Level().CurrentEntity());
	if (pA) {
		Actor()->Cameras().AddCamEffector(new CMonsterEffectorHit(db().m_attack_effector.ce_time,db().m_attack_effector.ce_amplitude,db().m_attack_effector.ce_period_number,db().m_attack_effector.ce_power));
		Actor()->Cameras().AddPPEffector(new CMonsterEffector(db().m_attack_effector.ppi, db().m_attack_effector.time, db().m_attack_effector.time_attack, db().m_attack_effector.time_release));
	}
}

void CBaseMonster::Hit_Psy(CObject *object, float value) 
{
	NET_Packet		P;
	SHit			HS;
	HS.GenHeader		(GE_HIT, object->ID());				//					//	u_EventGen		(P,GE_HIT, object->ID());				// 
	HS.whoID			= (ID());									// own		//	P.w_u16			(ID());									// own
	HS.weaponID			= (ID());									// own		//	P.w_u16			(ID());									// own
	HS.dir				= (Fvector().set(0.f,1.f,0.f));			// direction	//	P.w_dir			(Fvector().set(0.f,1.f,0.f));			// direction
	HS.power			= (value);								// hit value	//	P.w_float		(value);								// hit value
	HS.boneID			= (BI_NONE);								// bone		//	P.w_s16			(BI_NONE);								// bone
	HS.p_in_bone_space	= (Fvector().set(0.f,0.f,0.f));							//	P.w_vec3		(Fvector().set(0.f,0.f,0.f));			
	HS.impulse			= (0.f);												//	P.w_float		(0.f);									
	HS.hit_type			= (ALife::eHitTypeTelepatic);							//	P.w_u16			(u16(ALife::eHitTypeTelepatic));
	HS.use_secondary	= false;
	HS.Write_Packet	(P);
	u_EventSend		(P);
}

bool CBaseMonster::critical_wound_external_conditions_suitable	()
{
	if (!control().check_start_conditions(ControlCom::eControlSequencer)) 
		return false;

	if (!anim().IsStandCurAnim()) return false;

	return true;
}

void CBaseMonster::critical_wounded_state_start() 
{
	VERIFY	(m_critical_wound_type != u32(-1));

	LPCSTR anim = 0;
	switch (m_critical_wound_type)	{
	case critical_wound_type_head:
		anim = m_critical_wound_anim_head;
		break;
	case critical_wound_type_torso:
		anim = m_critical_wound_anim_torso;
		break;
	case critical_wound_type_legs:
		anim = m_critical_wound_anim_legs;
		break;
	}

	VERIFY	(anim);
	com_man().critical_wound(anim);	
}


IC void CBaseMonster::set_custom_panic_threshold(float value)
{
	m_panic_threshold = value;
}

IC void CBaseMonster::set_default_panic_threshold()
{
	m_panic_threshold = m_default_panic_threshold;
}

//Miscellanious functions for all the biting monsters

////////////////////////////////////////////////////////////////////////////////////////////////////////
// Входные воздействия 
// Зрение, слух, вероятность победы, выгодность противника
void CBaseMonster::UpdateMemory()
{
	// Обновить память
	EnemyMemory.update			();
	SoundMemory.UpdateHearing	();	
	CorpseMemory.update			();
	HitMemory.update			();
	
	// обновить менеджеры врагов и трупов
	EnemyMan.update				();	
	CorpseMan.update			();
		
	// remove hit info from objects that are corpses
	

	hear_dangerous_sound = hear_interesting_sound = false;
	SoundElem se;
	
	if (SoundMemory.IsRememberSound()) {
		SoundMemory.GetSound(se,hear_dangerous_sound);
		hear_interesting_sound = !hear_dangerous_sound;
	}

	// Setup is own additional flags
	m_bDamaged		= ((conditions().GetHealth() < db().m_fDamagedThreshold) ? true : false);
	
	m_bAggressive	=	hear_dangerous_sound || (EnemyMan.get_enemies_count() > 0) || 
						HitMemory.is_hit();

}

void CBaseMonster::net_Save			(NET_Packet& P)
{
	inherited::net_Save(P);
	m_pPhysics_support->in_NetSave(P);
}

BOOL CBaseMonster::net_SaveRelevant	()
{
	return (inherited::net_SaveRelevant() || BOOL(PPhysicsShell()!=NULL));
}

void CBaseMonster::net_Export(NET_Packet& P) 
{
	R_ASSERT				(Local());

	// export last known packet
	R_ASSERT				(!NET.empty());
	net_update& N			= NET.back();
	P.w_float				(GetfHealth());
	P.w_u32					(N.dwTimeStamp);
	P.w_u8					(0);
	P.w_vec3				(N.p_pos);
	P.w_float /*w_angle8*/				(N.o_model);
	P.w_float /*w_angle8*/				(N.o_torso.yaw);
	P.w_float /*w_angle8*/				(N.o_torso.pitch);
	P.w_float /*w_angle8*/				(N.o_torso.roll);
	P.w_u8					(u8(g_Team()));
	P.w_u8					(u8(g_Squad()));
	P.w_u8					(u8(g_Group()));

	GameGraph::_GRAPH_ID		l_game_vertex_id = ai_location().game_vertex_id();
	P.w						(&l_game_vertex_id,			sizeof(l_game_vertex_id));
	P.w						(&l_game_vertex_id,			sizeof(l_game_vertex_id));
//	P.w						(&m_fGoingSpeed,			sizeof(m_fGoingSpeed));
//	P.w						(&m_fGoingSpeed,			sizeof(m_fGoingSpeed));
	float					f1 = 0;
	if (ai().game_graph().valid_vertex_id(l_game_vertex_id)) {
		f1					= Position().distance_to	(ai().game_graph().vertex(l_game_vertex_id)->level_point());
		P.w					(&f1,						sizeof(f1));
		f1					= Position().distance_to	(ai().game_graph().vertex(l_game_vertex_id)->level_point());
		P.w					(&f1,						sizeof(f1));
	}
	else {
		P.w					(&f1,						sizeof(f1));
		P.w					(&f1,						sizeof(f1));
	}

}

void CBaseMonster::net_Import(NET_Packet& P)
{
	R_ASSERT				(Remote());
	net_update				N;

	u8 flags;

	float health;
	P.r_float			(health);
	SetfHealth			(health);

	P.r_u32					(N.dwTimeStamp);
	P.r_u8					(flags);
	P.r_vec3				(N.p_pos);
	P.r_float /*r_angle8*/				(N.o_model);
	P.r_float /*r_angle8*/				(N.o_torso.yaw);
	P.r_float /*r_angle8*/				(N.o_torso.pitch);
	P.r_float /*r_angle8*/				(N.o_torso.roll	);
	id_Team					= P.r_u8();
	id_Squad				= P.r_u8();
	id_Group				= P.r_u8();

	GameGraph::_GRAPH_ID		l_game_vertex_id = ai_location().game_vertex_id();
	P.r						(&l_game_vertex_id,			sizeof(l_game_vertex_id));
	P.r						(&l_game_vertex_id,			sizeof(l_game_vertex_id));

	if (NET.empty() || (NET.back().dwTimeStamp<N.dwTimeStamp))	{
		NET.push_back			(N);
		NET_WasInterpolating	= TRUE;
	}

//	P.r						(&m_fGoingSpeed,			sizeof(m_fGoingSpeed));
//	P.r						(&m_fGoingSpeed,			sizeof(m_fGoingSpeed));
	float					f1 = 0;
	if (ai().game_graph().valid_vertex_id(l_game_vertex_id)) {
		f1					= Position().distance_to	(ai().game_graph().vertex(l_game_vertex_id)->level_point());
		P.r					(&f1,						sizeof(f1));
		f1					= Position().distance_to	(ai().game_graph().vertex(l_game_vertex_id)->level_point());
		P.r					(&f1,						sizeof(f1));
	}
	else {
		P.r					(&f1,						sizeof(f1));
		P.r					(&f1,						sizeof(f1));
	}


	setVisible				(TRUE);
	setEnabled				(TRUE);
}

////////////////////////////////////////////////////////////////////////////

//	Description : Path finding, curve building, position prediction
////////////////////////////////////////////////////////////////////////////



// каждый монстр может по-разному реализвать эту функ (e.g. кровосос с поворотом головы и т.п.)
void CBaseMonster::LookPosition(Fvector to_point, float angular_speed)
{
	// по-умолчанию просто изменить movement().m_body.target.yaw
	Fvector	d;
	d.set(to_point);
	d.sub(Position());	
	
	// установить текущий угол
	dir().set_heading(angle_normalize(-d.getH()));
}

//////////////////////////////////////////////////////////////////////////
// Covers
//////////////////////////////////////////////////////////////////////////

bool CBaseMonster::GetCorpseCover(Fvector &position, u32 &vertex_id) 
{
	m_corpse_cover_evaluator->setup(10.f,50.f);
	const CCoverPoint *point = ai().cover_manager().best_cover(Position(),30.f,*m_corpse_cover_evaluator);
	if (!point) return false;
	
	position	= point->m_position;
	vertex_id	= point->m_level_vertex_id;
	return true;
}

bool CBaseMonster::GetCoverFromEnemy(const Fvector &enemy_pos, Fvector &position, u32 &vertex_id) 
{
	m_enemy_cover_evaluator->setup(enemy_pos, 30.f,50.f);
	const CCoverPoint	 *point = ai().cover_manager().best_cover(Position(),40.f,*m_enemy_cover_evaluator);
	if (!point) return false;

	position	= point->m_position;
	vertex_id	= point->m_level_vertex_id;
	return true;
}

bool CBaseMonster::GetCoverFromPoint(const Fvector &pos, Fvector &position, u32 &vertex_id, float min_dist, float max_dist, float radius) 
{
	m_enemy_cover_evaluator->setup(pos, min_dist,max_dist);
	const CCoverPoint	 *point = ai().cover_manager().best_cover(Position(),radius,*m_enemy_cover_evaluator);
	if (!point) return false;

	position	= point->m_position;
	vertex_id	= point->m_level_vertex_id;
	return true;
}

bool CBaseMonster::GetCoverCloseToPoint(const Fvector &dest_pos, float min_dist, float max_dist, float deviation, float radius ,Fvector &position, u32 &vertex_id) 
{
	m_cover_evaluator_close_point->setup(dest_pos,min_dist, max_dist,deviation);
	const CCoverPoint	 *point = ai().cover_manager().best_cover(Position(),radius,*m_cover_evaluator_close_point);
	if (!point) return false;

	position	= point->m_position;
	vertex_id	= point->m_level_vertex_id;
	return true;
}


//////////////////////////////////////////////////////////////////////////
bool CBaseMonster::bfAssignMovement (CScriptEntityAction *tpEntityAction)
{
	CScriptMovementAction	&l_tMovementAction	= tpEntityAction->m_tMovementAction;
	
	// check if completed
	if (l_tMovementAction.m_bCompleted)	return(false);

	// check if alive
	CEntityAlive *entity_alive = smart_cast<CEntityAlive*>(this);
	if (entity_alive && !entity_alive->g_Alive()) {
		l_tMovementAction.m_bCompleted = true;
		return				(false);
	}

	if (control().path_builder().detail().time_path_built() >= tpEntityAction->m_tActionCondition.m_tStartTime) {
		if ((l_tMovementAction.m_fDistToEnd > 0) && control().path_builder().is_path_end(l_tMovementAction.m_fDistToEnd))  {
			l_tMovementAction.m_bCompleted = true;
			
		}
		if (control().path_builder().actual_all() && control().path_builder().path_completed()) {
			l_tMovementAction.m_bCompleted = true;
			return false;
		}
	}

	// translate script.action into anim().action
	switch (l_tMovementAction.m_tMoveAction) {
	case eMA_WalkFwd:	anim().m_tAction = ACT_WALK_FWD;		break;
	case eMA_WalkBkwd:	anim().m_tAction = ACT_WALK_BKWD;	break;
	case eMA_Run:		anim().m_tAction = ACT_RUN;			break;
	case eMA_Drag:		anim().m_tAction = ACT_DRAG;			break;
	case eMA_Steal:		anim().m_tAction = ACT_STEAL;		break;
	}

	m_force_real_speed = (l_tMovementAction.m_tSpeedParam == eSP_ForceSpeed);

	switch (l_tMovementAction.m_tGoalType) {
		
		case CScriptMovementAction::eGoalTypeObject : {
			CGameObject		*l_tpGameObject = smart_cast<CGameObject*>(l_tMovementAction.m_tpObjectToGo);
			path().set_target_point	(l_tpGameObject->Position(), l_tpGameObject->ai_location().level_vertex_id());
			break;
													  }
		case CScriptMovementAction::eGoalTypePatrolPath : 
			path().set_patrol_path_type							();
			control().path_builder().set_path_type				(MovementManager::ePathTypePatrolPath);
			control().path_builder().patrol().set_path			(l_tMovementAction.m_path,l_tMovementAction.m_path_name);
			control().path_builder().patrol().set_start_type	(l_tMovementAction.m_tPatrolPathStart);
			control().path_builder().patrol().set_route_type	(l_tMovementAction.m_tPatrolPathStop);
			control().path_builder().patrol().set_random		(l_tMovementAction.m_bRandom);
			if (l_tMovementAction.m_previous_patrol_point != u32(-1)) {
				control().path_builder().patrol().set_previous_point(l_tMovementAction.m_previous_patrol_point);
			}
			break;

		case CScriptMovementAction::eGoalTypePathPosition :
		case CScriptMovementAction::eGoalTypeNoPathPosition :
			path().set_target_point	(l_tMovementAction.m_tDestinationPosition);
			break;
		case CScriptMovementAction::eGoalTypePathNodePosition :
			path().set_target_point	(l_tMovementAction.m_tDestinationPosition, l_tMovementAction.m_tNodeID);
			break;
	}
	
	return	(true);
}

///////////////////////////////////////////////////////////////////////////
bool CBaseMonster::bfAssignObject(CScriptEntityAction *tpEntityAction)
{
	if (!inherited::bfAssignObject(tpEntityAction))
		return	(false);

//	CScriptObjectAction	&l_tObjectAction = tpEntityAction->m_tObjectAction;
//	if (!l_tObjectAction.m_tpObject)
//		return	(false == (l_tObjectAction.m_bCompleted = true));
//
//	CEntityAlive	*l_tpEntity		= smart_cast<CEntityAlive*>(l_tObjectAction.m_tpObject);
//	if (!l_tpEntity) return	(false == (l_tObjectAction.m_bCompleted = true));
//
//	switch (l_tObjectAction.m_tGoalType) {
//		case eObjectActionTake: 
//			m_PhysicMovementControl->PHCaptureObject(l_tpEntity);
//			break;
//		case eObjectActionDrop: 
//			m_PhysicMovementControl->PHReleaseObject();
//			break;
//	}
//	
//	l_tObjectAction.m_bCompleted = true;
	return	(true);
}


bool CBaseMonster::bfAssignWatch(CScriptEntityAction *tpEntityAction)
{
	if (!inherited::bfAssignWatch(tpEntityAction))
		return		(false);
	
	// Инициализировать action
	anim().m_tAction = ACT_STAND_IDLE;

	CScriptWatchAction	&l_tWatchAction = tpEntityAction->m_tWatchAction;
	if (l_tWatchAction.completed()) return false;

	Fvector new_pos;
	switch (l_tWatchAction.m_tWatchType) {
		case SightManager::eSightTypePosition:
			LookPosition(l_tWatchAction.m_tWatchVector);
			break;
		case SightManager::eSightTypeDirection:
			new_pos.mad(Position(), l_tWatchAction.m_tWatchVector, 2.f);
			LookPosition(new_pos);
			break;
	}


	if (!control().direction().is_turning())
		l_tWatchAction.m_bCompleted = true;
	else
		l_tWatchAction.m_bCompleted = false;
	
	return		(!l_tWatchAction.m_bCompleted);
}

bool CBaseMonster::bfAssignAnimation(CScriptEntityAction *tpEntityAction)
{
	if (!inherited::bfAssignAnimation(tpEntityAction))
		return			(false);

	CScriptAnimationAction	&l_tAnimAction	= tpEntityAction->m_tAnimationAction;
	if (l_tAnimAction.completed()) return false;
	
	// translate animation.action into anim().action
	switch (l_tAnimAction.m_tAnimAction) {
	case eAA_StandIdle:		anim().m_tAction = ACT_STAND_IDLE;	break;
	case eAA_SitIdle:		anim().m_tAction = ACT_SIT_IDLE;		break;
	case eAA_LieIdle:		anim().m_tAction = ACT_LIE_IDLE;		break;
	case eAA_Eat:			anim().m_tAction = ACT_EAT;			break;
	case eAA_Sleep:			anim().m_tAction = ACT_SLEEP;		break;
	case eAA_Rest:			anim().m_tAction = ACT_REST;			break;
	case eAA_Attack:		anim().m_tAction = ACT_ATTACK;		break;
	case eAA_LookAround:	anim().m_tAction = ACT_LOOK_AROUND;	break;
	}

	return				(true);
}

bool CBaseMonster::bfAssignSound(CScriptEntityAction *tpEntityAction)
{
	CScriptSoundAction	&l_tAction = tpEntityAction->m_tSoundAction;
	if (l_tAction.completed()) return false;

	if (l_tAction.m_monster_sound == MonsterSound::eMonsterSoundDummy) {
		if (!inherited::bfAssignSound(tpEntityAction))
			return			(false);
	}

	switch (l_tAction.m_monster_sound) {
	case	eMonsterSoundIdle:			sound().play(eMonsterSoundIdle,			0, 0, (l_tAction.m_monster_sound_delay == int(-1)) ? db().m_dwIdleSndDelay		: l_tAction.m_monster_sound_delay);		break;
	case 	eMonsterSoundEat:			sound().play(eMonsterSoundEat,			0, 0, (l_tAction.m_monster_sound_delay == int(-1)) ? db().m_dwEatSndDelay		: l_tAction.m_monster_sound_delay);		break;
	case 	eMonsterSoundAggressive:	sound().play(eMonsterSoundAggressive,	0, 0, (l_tAction.m_monster_sound_delay == int(-1)) ? db().m_dwAttackSndDelay	: l_tAction.m_monster_sound_delay);		break;
	case	eMonsterSoundAttackHit:		sound().play(eMonsterSoundAttackHit);	break;
	case	eMonsterSoundTakeDamage:	sound().play(eMonsterSoundTakeDamage);	break;
	case	eMonsterSoundDie:			sound().play(eMonsterSoundDie);			break;
	case	eMonsterSoundThreaten:		sound().play(eMonsterSoundThreaten,		0, 0, (l_tAction.m_monster_sound_delay == int(-1)) ? db().m_dwAttackSndDelay : l_tAction.m_monster_sound_delay);		break;
	case	eMonsterSoundSteal:			sound().play(eMonsterSoundSteal,		0, 0, (l_tAction.m_monster_sound_delay == int(-1)) ? db().m_dwAttackSndDelay : l_tAction.m_monster_sound_delay);		break;
	case	eMonsterSoundPanic:			sound().play(eMonsterSoundPanic,		0, 0, (l_tAction.m_monster_sound_delay == int(-1)) ? db().m_dwAttackSndDelay : l_tAction.m_monster_sound_delay);		break;
	}

	return				(true);
}

bool CBaseMonster::bfAssignMonsterAction(CScriptEntityAction *tpEntityAction)
{
	if (!inherited::bfAssignMonsterAction(tpEntityAction)) return false;
	
	CScriptMonsterAction	&l_tAction = tpEntityAction->m_tMonsterAction;	
	if (l_tAction.completed()) return false;

	CEntityAlive *pE = smart_cast<CEntityAlive *>(l_tAction.m_tObject);

	switch(l_tAction.m_tAction) {
		case eGA_Rest:		
			StateMan->force_script_state(eStateRest);	
			break;
		case eGA_Eat:		
			if (pE && !pE->getDestroy() && !pE->g_Alive()){
				CorpseMan.force_corpse(pE);
				StateMan->force_script_state(eStateEat);	
			} else StateMan->force_script_state(eStateRest);	

			break;
		case eGA_Attack:
			if (pE && !pE->getDestroy() && pE->g_Alive()){
				EnemyMan.force_enemy(pE);
				StateMan->force_script_state(eStateAttack);
			} else StateMan->force_script_state(eStateRest);

			break;
		case eGA_Panic:		
			if (pE && !pE->getDestroy() && pE->g_Alive()){
				EnemyMan.force_enemy			(pE);
				StateMan->force_script_state	(eStatePanic);
			} else StateMan->force_script_state	(eStateRest);	
			break;
	}

	m_script_state_must_execute = true;
	return (!l_tAction.m_bCompleted);
}



void CBaseMonster::ProcessScripts()
{
	if (!g_Alive()) return;
	if (m_script_processing_active) return;
	
	m_script_processing_active = true;

	//movement().Update_Initialize			();
	
	// Выполнить скриптовые actions
	m_script_state_must_execute					= false;
	inherited::ProcessScripts					();

	Device.dwTimeGlobal							= Device.dwTimeGlobal;

	// обновить мир (память, враги, объекты)
	UpdateMemory								();
	
	anim().accel_deactivate					();

	// если из скрипта выбрано действие по универсальной схеме, выполнить его
	if (m_script_state_must_execute) 	
		StateMan->execute_script_state			();		
	
	TranslateActionToPathParams					();

	// обновить путь
	//movement().Update_Execute			();

	//anim().Update							();
	
	// установить текущую скорость
	//movement().Update_Finalize			();

	// Удалить все враги и объекты, которые были принудительно установлены
	// во время выполнения скриптового действия
	if (m_script_state_must_execute) {
		EnemyMan.unforce_enemy();
		CorpseMan.unforce_corpse();
	}

	m_force_real_speed			= false;
	m_script_processing_active	= false;

#ifdef DEBUG	
	if (psAI_Flags.test(aiMonsterDebug)) {
		DBG().object_info(this,this).remove_item (u32(0));
		DBG().object_info(this,this).remove_item (u32(1));
		DBG().object_info(this,this).add_item	 (*cName(), D3DCOLOR_XRGB(255,0,0), 0);
		DBG().object_info(this,this).add_item	 ("Under script", D3DCOLOR_XRGB(255,0,0), 1);
	} else {
		DBG().object_info(this,this).clear		 ();
	}
#endif

}

CEntity *CBaseMonster::GetCurrentEnemy()
{
	CEntity *enemy = 0;
	
	if (EnemyMan.get_enemy()) 
		enemy = const_cast<CEntity *>(smart_cast<const CEntity*>(EnemyMan.get_enemy()));

	if (!enemy || enemy->getDestroy() || !enemy->g_Alive()) enemy = 0;

	return (enemy);
}

CEntity *CBaseMonster::GetCurrentCorpse()
{
	CEntity *corpse = 0;

	if (CorpseMan.get_corpse()) 
		corpse = const_cast<CEntity *>(smart_cast<const CEntity*>(CorpseMan.get_corpse()));

	if (!corpse || corpse->getDestroy() || corpse->g_Alive()) corpse = 0;

	return (corpse);
}

void CBaseMonster::SetScriptControl(const bool bScriptControl, shared_str caScriptName)
{
	if (StateMan) StateMan->critical_finalize();

	CScriptEntity::SetScriptControl(bScriptControl, caScriptName);
}

int	CBaseMonster::get_enemy_strength()
{
	if (EnemyMan.get_enemy()) {
		switch (EnemyMan.get_danger_type()) {
			case eVeryStrong	: 	return (4);
			case eStrong		: 	return (3);
			case eNormal		: 	return (2);
			case eWeak			:	return (1);
		}
	}
	
	return (0);
}

void CBaseMonster::vfFinishAction(CScriptEntityAction *tpEntityAction)
{
	inherited::vfFinishAction(tpEntityAction);
}


void CBaseMonster::Load(LPCSTR section)
{
	// load parameters from ".ltx" file
	inherited::Load					(section);

	m_corpse_cover_evaluator		= new CMonsterCorpseCoverEvaluator(&movement().restrictions());
	m_enemy_cover_evaluator			= new CCoverEvaluatorFarFromEnemy(&movement().restrictions());
	m_cover_evaluator_close_point	= new CCoverEvaluatorCloseToEnemy(&movement().restrictions());

	movement().Load					(section);

	MeleeChecker.load				(section);
	Morale.load						(section);

	m_pPhysics_support				->in_Load(section);

	SetfHealth						( (float)pSettings->r_u32		(section,"Health"));

	m_controlled					= smart_cast<CControlledEntityBase*>(this);

	settings_load					(section);

	control().load					(section);

	m_anomaly_detector->load		(section);
	CoverMan->load					();

	m_rank							= (pSettings->line_exist(section,"rank")) ? int(pSettings->r_u32(section,"rank")) : 0;

//	if (pSettings->line_exist(section,"Spawn_Inventory_Item_Section")) {
//		m_item_section					= pSettings->r_string(section,"Spawn_Inventory_Item_Section");
//		m_spawn_probability				= pSettings->r_float(section,"Spawn_Inventory_Item_Probability");
//	} else m_spawn_probability			= 0.f;

	m_melee_rotation_factor			= READ_IF_EXISTS(pSettings,r_float,section,"Melee_Rotation_Factor", 1.5f);
	berserk_always					= !!READ_IF_EXISTS(pSettings,r_bool,section,"berserk_always", false);
	hit_type						= ALife::g_tfString2HitType(pSettings->r_string(section, "hit_type"));
	hit_power						= READ_IF_EXISTS(pSettings, r_float, section, "hit_power", 1.0f);
	hit_mark						= pSettings->r_string(section, "hit_mark");
	jump_hit_type					= ALife::g_tfString2HitType(READ_IF_EXISTS(pSettings, r_string, section, "jump_hit_type", "wound"));
	jump_hit_mark					= READ_IF_EXISTS(pSettings, r_string, section, "jump_hit_mark", "monster_wound_jump");

	if (pSettings->line_exist(section,"vampire_speed")) {
		m_vampire_want_speed = !!pSettings->r_float (section,"vampire_speed");
	}

	//------------------------------------
	// Auras
	//------------------------------------

	m_psy_aura.load_from_ini(pSettings, section);
	m_radiation_aura.load_from_ini(pSettings, section);
	m_fire_aura.load_from_ini(pSettings, section);
	m_shock_aura.load_from_ini(pSettings, section);
	m_chemical_aura.load_from_ini(pSettings, section);
	m_biological_aura.load_from_ini(pSettings, section);
	m_base_aura.load_from_ini(pSettings, section);

	//------------------------------------
	// Protections
	//------------------------------------
	m_fSkinArmor = 0.f;
	m_fHitFracMonster = 0.1f;
	if (pSettings->line_exist(section, "protections_sect"))
	{
		LPCSTR protections_sect = pSettings->r_string(section, "protections_sect");
		m_fSkinArmor = READ_IF_EXISTS(pSettings, r_float, protections_sect, "skin_armor", 0.f);
		m_fHitFracMonster = READ_IF_EXISTS(pSettings, r_float, protections_sect, "hit_fraction_monster", 0.1f);
		m_fWeakHitFracMonster = READ_IF_EXISTS(pSettings, r_float, protections_sect, "weak_hit_fraction_monster", 0.0f);
	}
}

// if sound is absent just do not load that one
#define LOAD_SOUND(sound_name,_type,_prior,_mask,_int_type)		\
	if (pSettings->line_exist(section,sound_name))						\
		sound().add(pSettings->r_string(section,sound_name), DEFAULT_SAMPLE_COUNT,_type,_prior,u32(_mask),_int_type,"bip01_head");

void CBaseMonster::reload	(LPCSTR section)
{
	CCustomMonster::reload		(section);
	
	if (!CCustomMonster::use_simplified_visual())
		CStepManager::reload	(section);

	CInventoryOwner::reload		(section);
	movement().reload	(section);

	// load base sounds
	LOAD_SOUND("sound_idle",			SOUND_TYPE_MONSTER_TALKING,		MonsterSound::eLowPriority,			MonsterSound::eBaseChannel,			MonsterSound::eMonsterSoundIdle);
	LOAD_SOUND("sound_distant_idle",	SOUND_TYPE_MONSTER_TALKING,		MonsterSound::eLowPriority+1,		MonsterSound::eBaseChannel,			MonsterSound::eMonsterSoundIdleDistant);
	LOAD_SOUND("sound_eat",				SOUND_TYPE_MONSTER_TALKING,		MonsterSound::eNormalPriority + 4,	MonsterSound::eBaseChannel,			MonsterSound::eMonsterSoundEat);
	LOAD_SOUND("sound_aggressive",		SOUND_TYPE_MONSTER_ATTACKING,	MonsterSound::eNormalPriority + 3,	MonsterSound::eBaseChannel,			MonsterSound::eMonsterSoundAggressive);
	LOAD_SOUND("sound_attack_hit",		SOUND_TYPE_MONSTER_ATTACKING,	MonsterSound::eHighPriority + 1,	MonsterSound::eCaptureAllChannels,	MonsterSound::eMonsterSoundAttackHit);
	LOAD_SOUND("sound_take_damage",		SOUND_TYPE_MONSTER_INJURING,	MonsterSound::eHighPriority,		MonsterSound::eCaptureAllChannels,	MonsterSound::eMonsterSoundTakeDamage);
	LOAD_SOUND("sound_strike",			SOUND_TYPE_MONSTER_ATTACKING,	MonsterSound::eNormalPriority,		MonsterSound::eChannelIndependent,	MonsterSound::eMonsterSoundStrike);
	LOAD_SOUND("sound_die",				SOUND_TYPE_MONSTER_DYING,		MonsterSound::eCriticalPriority,	MonsterSound::eCaptureAllChannels,	MonsterSound::eMonsterSoundDie);
	LOAD_SOUND("sound_die_in_anomaly",	SOUND_TYPE_MONSTER_DYING,		MonsterSound::eCriticalPriority,	MonsterSound::eCaptureAllChannels,	MonsterSound::eMonsterSoundDieInAnomaly);
	LOAD_SOUND("sound_threaten",		SOUND_TYPE_MONSTER_ATTACKING,	MonsterSound::eNormalPriority,		MonsterSound::eBaseChannel,			MonsterSound::eMonsterSoundThreaten);
	LOAD_SOUND("sound_steal",			SOUND_TYPE_MONSTER_STEP,		MonsterSound::eNormalPriority + 1,	MonsterSound::eBaseChannel,			MonsterSound::eMonsterSoundSteal);
	LOAD_SOUND("sound_panic",			SOUND_TYPE_MONSTER_STEP,		MonsterSound::eNormalPriority + 2,	MonsterSound::eBaseChannel,			MonsterSound::eMonsterSoundPanic);
	
	control().reload					(section);

	// load monster type
	m_monster_type = eMonsterTypeUniversal;
	if (pSettings->line_exist(section,"monster_type")) {
		if (xr_strcmp(pSettings->r_string(section,"monster_type"), "indoor") == 0)
			m_monster_type = eMonsterTypeIndoor;
		else if (xr_strcmp(pSettings->r_string(section,"monster_type"), "outdoor") == 0)
			m_monster_type = eMonsterTypeOutdoor;
	}

	Home->load						("home");

	// save panic_threshold
	m_default_panic_threshold = m_panic_threshold;
}


void CBaseMonster::reinit()
{
	inherited::reinit					();
	CInventoryOwner::reinit				();

	EnemyMemory.clear					();
	SoundMemory.clear					();
	CorpseMemory.clear					();
	HitMemory.clear						();

	EnemyMan.reinit						();
	CorpseMan.reinit					();

	StateMan->reinit					();
	
	Morale.reinit						();

	m_bDamaged						= false;
	m_bAngry						= false;
	m_bAggressive					= false;
	m_bSleep						= false;
	m_bRunTurnLeft					= false;
	m_bRunTurnRight					= false;

	state_invisible					= false;

	m_force_real_speed				= false;
	m_script_processing_active		= false;

	if (m_controlled)				m_controlled->on_reinit();

	ignore_collision_hit			= false;

	control().reinit				();

	m_anomaly_detector->reinit		();

	m_skip_transfer_enemy			= false;

	MeleeChecker.init_attack		();

	time_berserk_start				= 0;

	m_prev_sound_type				= MonsterSound::eMonsterSoundIdle;

#ifdef DEBUG
	m_show_debug_info				= 0;
#endif 
	
}


BOOL CBaseMonster::net_Spawn (CSE_Abstract* DC) 
{
	if (!inherited::net_Spawn(DC))
		return(FALSE);

	CSE_Abstract							*e	= (CSE_Abstract*)(DC);
#ifndef PRIQUEL
	m_pPhysics_support->in_NetSpawn			(e);//этот выззов с послудующими не связан, 
												//но там есть хак - запуск анимации на всякий случай если никто больше ее не запустил 
												//поэтому в основной версии на всякий случай пусть будет здесь, 
												//но для animation movement controllr он должен быть в конце чтобы знать что он создался на споне
#endif

	R_ASSERT2								(ai().get_level_graph() && ai().get_cross_table() && (ai().level_graph().level_id() != u32(-1)),"There is no AI-Map, level graph, cross table, or graph is not compiled into the game graph!");

	monster_squad().register_member			((u8)g_Team(),(u8)g_Squad(),(u8)g_Group(), this);

	settings_overrides						();

#ifdef PRIQUEL
	if (GetScriptControl()) {
		m_control_manager->animation().reset_data	();
		ProcessScripts						();
	}
	m_pPhysics_support->in_NetSpawn			(e);
#endif


	// spawn inventory item
//	if (ai().get_alife()) {
//		
//		CSE_ALifeMonsterBase					*se_monster = smart_cast<CSE_ALifeMonsterBase*>(ai().alife().objects().object(ID()));
//		VERIFY									(se_monster);
//
//		if (se_monster->m_flags.is(CSE_ALifeMonsterBase::flNeedCheckSpawnItem)) {
//			float prob = Random.randF();
//			if ((prob < m_spawn_probability) || fsimilar(m_spawn_probability,1.f)) 
//				se_monster->m_flags.set(CSE_ALifeMonsterBase::flSkipSpawnItem, FALSE);
//
//			se_monster->m_flags.set(CSE_ALifeMonsterBase::flNeedCheckSpawnItem, FALSE);
//		}
//
//		if (!se_monster->m_flags.is(CSE_ALifeMonsterBase::flSkipSpawnItem)) {
//			CSE_Abstract	*object = Level().spawn_item (m_item_section,Position(),ai_location().level_vertex_id(),ID(),true);
//			CSE_ALifeObject	*alife_object = smart_cast<CSE_ALifeObject*>(object);
//			if (alife_object)
//				alife_object->m_flags.set	(CSE_ALifeObject::flCanSave,FALSE);
//
//			{
//				NET_Packet				P;
//				object->Spawn_Write		(P,TRUE);
//				Level().Send			(P,net_flags(TRUE));
//				F_entity_Destroy		(object);
//			}
//		}
//	}

	return(TRUE);
}

void CBaseMonster::net_Destroy()
{
	// функция должена быть вызвана перед inherited
	if (m_controlled) m_controlled->on_destroy	();
	if (StateMan) StateMan->critical_finalize	();

	inherited::net_Destroy				();
	
	CInventoryOwner::net_Destroy		();

	m_pPhysics_support->in_NetDestroy	();

	monster_squad().remove_member		((u8)g_Team(),(u8)g_Squad(),(u8)g_Group(),this);

#ifdef DEBUG
	m_show_debug_info				= 0;
#endif 

}

#define READ_SETTINGS(var,name,method,ltx,section) {\
	if (ltx == pSettings) var = ltx->method(section,name); \
	else if (ltx->line_exist(section,name)) var = ltx->method(section,name);\
}

void CBaseMonster::settings_read(const CInifile *ini, LPCSTR section, SMonsterSettings &data)
{
	READ_SETTINGS(data.m_fSoundThreshold, "SoundThreshold", r_float, ini, section);

	if (ability_run_attack()) {
		READ_SETTINGS(data.m_run_attack_path_dist,	"RunAttack_PathDistance",	r_float, ini, section);
		READ_SETTINGS(data.m_run_attack_start_dist, "RunAttack_StartDistance",	r_float, ini, section);
	}

	READ_SETTINGS(data.m_dwDayTimeBegin,	"DayTime_Begin",		r_u32, ini, section);
	READ_SETTINGS(data.m_dwDayTimeEnd,		"DayTime_End",			r_u32, ini, section);

	READ_SETTINGS(data.m_fDistToCorpse,		"distance_to_corpse",	r_float, ini, section);
	READ_SETTINGS(data.satiety_threshold,	"satiety_threshold",	r_float, ini, section);

	READ_SETTINGS(data.m_fDamagedThreshold, "DamagedThreshold",		r_float, ini, section);

	READ_SETTINGS(data.m_dwIdleSndDelay,	"idle_sound_delay",		r_u32, ini, section);
	READ_SETTINGS(data.m_dwEatSndDelay,		"eat_sound_delay",		r_u32, ini, section);
	READ_SETTINGS(data.m_dwAttackSndDelay,	"attack_sound_delay",	r_u32, ini, section);

	READ_SETTINGS(data.m_dwDistantIdleSndDelay,	"distant_idle_sound_delay",	r_u32, ini, section);
	READ_SETTINGS(data.m_fDistantIdleSndRange,	"distant_idle_sound_range",	r_float, ini, section);

	READ_SETTINGS(data.m_fEatFreq,			"eat_freq",				r_float, ini, section);
	READ_SETTINGS(data.m_fEatSlice,			"eat_slice",			r_float, ini, section);
	READ_SETTINGS(data.m_fEatSliceWeight,	"eat_slice_weight",		r_float, ini, section);

	READ_SETTINGS(data.m_legs_number,		"LegsCount",			r_u8,	 ini, section);
	READ_SETTINGS(data.m_max_hear_dist,		"max_hear_dist",		r_float, ini, section);

	// Load attack postprocess 
	if (ini->line_exist(section,"attack_effector")) {

		LPCSTR ppi_section = ini->r_string(section, "attack_effector");

		READ_SETTINGS(data.m_attack_effector.ppi.duality.h,			"duality_h",		r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ppi.duality.v,			"duality_v",		r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ppi.gray,				"gray",				r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ppi.blur,				"blur",				r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ppi.noise.intensity,	"noise_intensity",	r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ppi.noise.grain,		"noise_grain",		r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ppi.noise.fps,			"noise_fps",		r_float, ini, ppi_section);

		VERIFY(!fis_zero(data.m_attack_effector.ppi.noise.fps));

		if (ini->line_exist(ppi_section,"color_base")) 
			sscanf(ini->r_string(ppi_section,"color_base"),	"%f,%f,%f", &data.m_attack_effector.ppi.color_base.r, &data.m_attack_effector.ppi.color_base.g, &data.m_attack_effector.ppi.color_base.b);		
		if (ini->line_exist(ppi_section,"color_base")) 
			sscanf(ini->r_string(ppi_section,"color_gray"),	"%f,%f,%f", &data.m_attack_effector.ppi.color_gray.r, &data.m_attack_effector.ppi.color_gray.g, &data.m_attack_effector.ppi.color_gray.b);
		if (ini->line_exist(ppi_section,"color_base")) 
			sscanf(ini->r_string(ppi_section,"color_add"),	"%f,%f,%f", &data.m_attack_effector.ppi.color_add.r,  &data.m_attack_effector.ppi.color_add.g,	&data.m_attack_effector.ppi.color_add.b);

		READ_SETTINGS(data.m_attack_effector.time,					"time",				r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.time_attack,			"time_attack",		r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.time_release,			"time_release",		r_float, ini, ppi_section);

		READ_SETTINGS(data.m_attack_effector.ce_time,				"ce_time",			r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ce_amplitude,			"ce_amplitude",		r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ce_period_number,		"ce_period_number",	r_float, ini, ppi_section);
		READ_SETTINGS(data.m_attack_effector.ce_power,				"ce_power",			r_float, ini, ppi_section);
	}
}

void CBaseMonster::settings_load(LPCSTR section)
{
	SMonsterSettings		data;

	settings_read			(pSettings, section, data);

	u32 crc					= crc32(&data,sizeof(SMonsterSettings));
	m_base_settings.create	(crc,1,&data);
}


void CBaseMonster::settings_overrides()
{
	SMonsterSettings			*data;
	data						= *m_base_settings;

	if (spawn_ini() && spawn_ini()->section_exist("settings_overrides")) {
		settings_read			(spawn_ini(),"settings_overrides", (*data));
	}

	u32 crc						= crc32(data,sizeof(SMonsterSettings));
	m_current_settings.create	(crc,1,data);
}

void CBaseMonster::on_before_sell	(CInventoryItem *item)
{
	// since there can be only single item in the monster inventory
	CSE_Abstract					*object	= Level().Server->game->get_entity_from_eid(item->object().ID()); 
	VERIFY							(object);
	CSE_ALifeObject					*alife_object = smart_cast<CSE_ALifeObject*>(object);
	if (alife_object)
		alife_object->m_flags.set	(CSE_ALifeObject::flCanSave,TRUE);
}

void CBaseMonster::load_critical_wound_bones()
{
	// animation does not exist - no bones loaded
	if (pSettings->line_exist(cNameSect(),"critical_wound_anim_head")) {
		fill_bones_body_parts			("critical_wound_bones_head",	critical_wound_type_head);
		m_critical_wound_anim_head		= pSettings->r_string(cNameSect(),"critical_wound_anim_head");
	} 

	if (pSettings->line_exist(cNameSect(),"critical_wound_anim_torso")) {
		fill_bones_body_parts			("critical_wound_bones_torso",	critical_wound_type_torso);
		m_critical_wound_anim_torso		= pSettings->r_string(cNameSect(),"critical_wound_anim_torso");

	} 
	
	if (pSettings->line_exist(cNameSect(),"critical_wound_anim_legs")) {
		fill_bones_body_parts			("critical_wound_bones_legs",	critical_wound_type_legs);
		m_critical_wound_anim_legs		= pSettings->r_string(cNameSect(),"critical_wound_anim_legs");
	} 
}

void CBaseMonster::fill_bones_body_parts	(LPCSTR body_part, CriticalWoundType wound_type)
{
	LPCSTR					body_parts_section = pSettings->r_string(cNameSect(),body_part);

	IKinematics				*kinematics	= smart_cast<IKinematics*>(Visual());
	VERIFY					(kinematics);

	CInifile::Sect			&body_part_section = pSettings->r_section(body_parts_section);
	CInifile::SectCIt		I = body_part_section.Data.begin();
	CInifile::SectCIt		E = body_part_section.Data.end();
	for ( ; I != E; ++I)
		m_bones_body_parts.insert	(
			std::make_pair(
				kinematics->LL_BoneID((*I).first),
				u32(wound_type)
			)
		);
}



void CBaseMonster::Think()
{
	START_PROFILE("Base Monster/Think");

	if (!g_Alive() || getDestroy())			return;

	// Инициализировать
	InitThink								();
	anim().ScheduledInit					();

	// Обновить память
	START_PROFILE("Base Monster/Think/Update Memory");
	UpdateMemory							();
	STOP_PROFILE;

	// Обновить сквад
	START_PROFILE("Base Monster/Think/Update Squad");
	monster_squad().update					(this);
	STOP_PROFILE;

	// Запустить FSM
	START_PROFILE("Base Monster/Think/FSM");
	update_fsm								();
	STOP_PROFILE;	
	
	STOP_PROFILE;
}

void CBaseMonster::update_fsm()
{
	StateMan->update				();
	
	// завершить обработку установленных в FSM параметров
	post_fsm_update					();
	
	TranslateActionToPathParams		();

	// информировать squad о своих целях
	squad_notify					();

#ifdef DEBUG
	debug_fsm						();
#endif
}

void CBaseMonster::post_fsm_update()
{
	if (!EnemyMan.get_enemy()) return;
	
	EMonsterState state = StateMan->get_state_type();


	// Look at enemy while running
	m_bRunTurnLeft = m_bRunTurnRight = false;
	

	if (is_state(state, eStateAttack) && control().path_builder().is_moving_on_path()) {

		float	dir_yaw = control().path_builder().detail().direction().getH();
		float	yaw_target = Fvector().sub(EnemyMan.get_enemy()->Position(), Position()).getH();

		float angle_diff	= angle_difference(yaw_target, dir_yaw);

		if ((angle_diff > PI_DIV_3) && (angle_diff < 5 * PI_DIV_6)) {
			if (from_right(dir_yaw, yaw_target))	m_bRunTurnRight = true;
			else									m_bRunTurnLeft	= true;
		}
	}
}

void CBaseMonster::squad_notify()
{
	CMonsterSquad	*squad = monster_squad().get_squad(this);
	SMemberGoal		goal;

	EMonsterState state = StateMan->get_state_type();

	if (is_state(state, eStateAttack)) {
		
		goal.type	= MG_AttackEnemy;
		goal.entity	= const_cast<CEntityAlive*>(EnemyMan.get_enemy());

	} else if (is_state(state, eStateRest)) {
		goal.entity	= squad->GetLeader();

		if (state == eStateRest_Idle)							goal.type	= MG_Rest;
		else if (state == eStateRest_WalkGraphPoint) 			goal.type	= MG_WalkGraph;
		else if (state == eStateRest_MoveToHomePoint) 			goal.type	= MG_WalkGraph;
		else if (state == eStateCustomMoveToRestrictor)			goal.type	= MG_WalkGraph;
		else if (state == eStateRest_WalkToCover)				goal.type	= MG_WalkGraph;
		else if (state == eStateRest_LookOpenPlace)				goal.type	= MG_Rest;
		else													goal.entity	= 0;

	} else if (is_state(state, eStateSquad)) {
		goal.type	= MG_Rest;
		goal.entity	= squad->GetLeader();
	}
	
	squad->UpdateGoal(this, goal);
}

